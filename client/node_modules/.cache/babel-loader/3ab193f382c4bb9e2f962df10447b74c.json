{"ast":null,"code":"/*!\n * XRegExp 3.1.1-next\n * <xregexp.com>\n * Steven Levithan (c) 2007-2016 MIT License\n */\n'use strict';\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\n\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  natives: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = /x/.flags !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar toString = {}.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag);\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  if (isSupported && flag === 'y') {\n    // Work around Safari 9.1.1 bug\n    return new RegExp('aa|.', 'y').test('b');\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var p;\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`addG` {Boolean} Add flag g while copying the regex.\n *   <li>`addY` {Boolean} Add flag y while copying the regex.\n *   <li>`removeG` {Boolean} Remove flag g while copying the regex.\n *   <li>`removeY` {Boolean} Remove flag y while copying the regex.\n *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   <li>`source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {},\n      flags = getNativeFlags(regex),\n      flagsToAdd = '',\n      flagsToRemove = '',\n      xregexpSource = null,\n      xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if (xData.flags != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\n\n\nfunction dec(hex) {\n  return parseInt(hex, 16);\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? regex.flags : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\n\n\nfunction hex(dec) {\n  return parseInt(dec, 10).toString(16);\n}\n/**\n * Returns the first index at which a given value can be found in an array.\n *\n * @private\n * @param {Array} array Array to search.\n * @param {*} value Value to locate in the array.\n * @returns {Number} Zero-based index at which the item is found, or -1.\n */\n\n\nfunction indexOf(array, value) {\n  var len = array.length,\n      i;\n\n  for (i = 0; i < len; ++i) {\n    if (array[i] === value) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === '[object ' + type + ']';\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  return nativ.test.call(flags.indexOf('x') > -1 ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, pattern.slice(pos));\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = '0' + str;\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  var i; // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError('Invalid duplicate regex flag ' + flags);\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  for (i = 0; i < flags.length; ++i) {\n    if (!registeredFlags[flags.charAt(i)]) {\n      throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));\n    }\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n/*\nfunction prepareOptions(value) {\n var options = {};\n  if (isType(value, 'String')) {\n     XRegExp.forEach(value, /[^\\s,]+/, function(match) {\n         options[match] = true;\n     });\n      return options;\n }\n  return value;\n}\n*/\n\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length,\n      leadChar = pattern.charAt(pos),\n      result = null,\n      match,\n      t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && flags.indexOf(t.flag) === -1) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n/*\nfunction setAstral(on) {\n features.astral = on;\n}\n*/\n\n/**\n * Enables or disables native method overrides.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNatives(on) {\n  RegExp.prototype.exec = (on ? fixed : nativ).exec;\n  RegExp.prototype.test = (on ? fixed : nativ).test;\n  String.prototype.match = (on ? fixed : nativ).match;\n  String.prototype.replace = (on ? fixed : nativ).replace;\n  String.prototype.split = (on ? fixed : nativ).split;\n  features.natives = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     <li>`g` - global\n *     <li>`i` - ignore case\n *     <li>`m` - multiline anchors\n *     <li>`u` - unicode (ES6)\n *     <li>`y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     <li>`n` - explicit capture\n *     <li>`s` - dot matches all (aka singleline)\n *     <li>`x` - free-spacing and line comments (aka extended)\n *     <li>`A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \\n\\\n *          (?<month> [0-9]{2} ) -?  # month \\n\\\n *          (?<day>   [0-9]{2} )     # day   ', 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = applied.flags; // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = new RegExp(); // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '3.1.1-next'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The regex scope where the match was found: 'default' or 'class'.\n *   <li>The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   function() {return '\\\\x07';},\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   function(match) {return match[1] + (match[2] ? '' : '?');},\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var optionalFlags = options.optionalFlags,\n      i;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n\n    for (i = 0; i < optionalFlags.length; ++i) {\n      registerFlag(optionalFlags[i]);\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n/*\nXRegExp.escape = function(str) {\n return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n*/\n\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * var match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * var pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g',\n      addY = false,\n      fakeY = false,\n      match,\n      r2;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? regex.source + '|()' : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The zero-based match index.\n *   <li>The string being traversed.\n *   <li>The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * var evens = [];\n * XRegExp.forEach('1a2345', /\\d/, function(match, i) {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n/*\nXRegExp.forEach = function(str, regex, callback) {\n var pos = 0,\n     i = -1,\n     match;\n  while ((match = XRegExp.exec(str, regex, pos))) {\n     // Because `regex` is provided to `callback`, the function could use the deprecated/\n     // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n     // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n     // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n     // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n     // which is a nice side effect that brings extra safety.\n     callback(match, ++i, str, regex);\n      pos = match.index + (match[0].length || 1);\n }\n};\n*/\n\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * var globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n/*\nXRegExp.globalize = function(regex) {\n return copyRegex(regex, {addG: true});\n};\n*/\n\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // DEPRECATED: Overrides native regex methods with fixed/extended versions\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral natives');\n */\n\n/*\nXRegExp.install = function(options) {\n options = prepareOptions(options);\n  if (!features.astral && options.astral) {\n     setAstral(true);\n }\n  if (!features.natives && options.natives) {\n     setNatives(true);\n }\n};\n*/\n\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   <li>`astral`\n *   <li>`natives`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]'; //return isType(value, 'RegExp');\n};\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n/*\nXRegExp.match = function(str, regex, scope) {\n var global = (regex.global && scope !== 'one') || scope === 'all',\n     cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',\n     result,\n     r2;\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n  // Shares cached copies with `XRegExp.exec`/`replace`\n r2 = regex[REGEX_DATA][cacheKey] || (\n     regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n         addG: !!global,\n         removeG: scope === 'one',\n         isInternalOnly: true\n     })\n );\n  result = nativ.match.call(toObject(str), r2);\n  if (regex.global) {\n     regex.lastIndex = (\n         (scope === 'one' && result) ?\n             // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n             (result.index + result[0].length) : 0\n     );\n }\n  return global ? (result || []) : (result && result[0]);\n};\n*/\n\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n/*XRegExp.matchChain = function(str, chain) {\n    return (function recurseChain(values, level) {\n        var item = chain[level].regex ? chain[level] : {regex: chain[level]};\n        var matches = [];\n\n        function addMatch(match) {\n            if (item.backref) {\n                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the\n                // `undefined`s for backreferences to nonparticipating capturing groups. In such\n                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw\n                // the exception, so also check if the backreference is a number that is within the\n                // bounds of the array.\n                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {\n                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);\n                }\n\n                matches.push(match[item.backref] || '');\n            } else {\n                matches.push(match[0]);\n            }\n        }\n\n        for (var i = 0; i < values.length; ++i) {\n            XRegExp.forEach(values[i], item.regex, addMatch);\n        }\n\n        return ((level === chain.length - 1) || !matches.length) ?\n            matches :\n            recurseChain(matches, level + 1);\n    }([str], 0));\n};\n*/\n\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement\n * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared\n * to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     <li>$$ - Inserts a literal $ character.\n *     <li>$&, $0 - Inserts the matched substring.\n *     <li>$` - Inserts the string that precedes the matched substring (left context).\n *     <li>$' - Inserts the string that follows the matched substring (right context).\n *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     <li>The zero-based index of the match within the total search string.\n *     <li>The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * var name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '${last}, ${first}');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, function(match) {\n *   return match.last + ', ' + match.first;\n * });\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search),\n      global = search.global && scope !== 'one' || scope === 'all',\n      cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY',\n      s2 = search,\n      result;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, function($0) {\n *     return $0.toUpperCase();\n *   }]\n * ]);\n */\n\n/*\nXRegExp.replaceEach = function(str, replacements) {\n var i, r;\n  for (i = 0; i < replacements.length; ++i) {\n     r = replacements[i];\n     str = XRegExp.replace(str, r[0], r[1], r[2]);\n }\n  return str;\n};\n*/\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n/*\nXRegExp.split = function(str, separator, limit) {\n return fixed.split.call(toObject(str), separator, limit);\n};\n*/\n\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n\n/*XRegExp.test = function(str, regex, pos, sticky) {\n    // Do this the easy way :-)\n    return !!XRegExp.exec(str, regex, pos, sticky);\n};\n*/\n\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // DEPRECATED: Restores native regex methods\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral natives');\n */\n\n/*\nXRegExp.uninstall = function(options) {\n options = prepareOptions(options);\n  if (features.astral && options.astral) {\n     setAstral(false);\n }\n  if (features.natives && options.natives) {\n     setNatives(false);\n }\n};\n*/\n\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n */\n\n/*\nXRegExp.union = function(patterns, flags) {\n var numCaptures = 0;\n var numPriorCaptures;\n var captureNames;\n  function rewrite(match, paren, backref) {\n     var name = captureNames[numCaptures - numPriorCaptures];\n      // Capturing group\n     if (paren) {\n         ++numCaptures;\n         // If the current capture has a name, preserve the name\n         if (name) {\n             return '(?<' + name + '>';\n         }\n     // Backreference\n     } else if (backref) {\n         // Rewrite the backreference\n         return '\\\\' + (+backref + numPriorCaptures);\n     }\n      return match;\n }\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n     throw new TypeError('Must provide a nonempty array of patterns to merge');\n }\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n var output = [];\n var pattern;\n for (var i = 0; i < patterns.length; ++i) {\n     pattern = patterns[i];\n      if (XRegExp.isRegExp(pattern)) {\n         numPriorCaptures = numCaptures;\n         captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];\n          // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n         // independently valid; helps keep this simple. Named captures are put back\n         output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n     } else {\n         output.push(XRegExp.escape(pattern));\n     }\n }\n  return XRegExp(output.join('|'), flags);\n};\n*/\n// ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to\n * override the native method. Use via `XRegExp.exec` without overriding natives.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex,\n      match = nativ.exec.apply(this, arguments),\n      name,\n      r2,\n      i;\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {\n      r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call(String(str).slice(match.index), r2, function () {\n        var len = arguments.length,\n            i; // Skip index 0 and the last 2\n\n        for (i = 1; i < len - 2; ++i) {\n          if (arguments[i] === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (i = 1; i < match.length; ++i) {\n        name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          match[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`\n * uses this to override the native method.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n\n/*fixed.test = function(str) {\n    // Do this the easy way :-)\n    return !!fixed.exec.call(this, str);\n};*/\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to\n * override the native method.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n/*fixed.match = function(regex) {\n    var result;\n\n    if (!XRegExp.isRegExp(regex)) {\n        // Use the native `RegExp` rather than `XRegExp`\n        regex = new RegExp(regex);\n    } else if (regex.global) {\n        result = nativ.match.apply(this, arguments);\n        // Fixes IE bug\n        regex.lastIndex = 0;\n\n        return result;\n    }\n\n    return fixed.exec.call(regex, toObject(this));\n};\n*/\n\n/**\n * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and\n * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser\n * bugs in replacement text syntax when performing a replacement using a nonregex search value, and\n * the value of a replacement regex's `lastIndex` property during replacement iterations and upon\n * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note\n * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via\n * `XRegExp.replace` without overriding natives.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search),\n      origLastIndex,\n      captureNames,\n      result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      var args = arguments,\n          i;\n\n      if (captureNames) {\n        // Change the `arguments[0]` string primitive to a `String` object that can store\n        // properties. This really does need to use `String` as a constructor\n        args[0] = new String(args[0]); // Store named backreferences on the first argument\n\n        for (i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            args[0][captureNames[i]] = args[i + 1];\n          }\n        }\n      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n\n\n      if (isRegex && search.global) {\n        search.lastIndex = args[args.length - 2] + args[0].length;\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(undefined, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      // Keep this function's `arguments` available through closure\n      var args = arguments;\n      return nativ.replace.call(String(replacement), replacementToken, function ($0, $1, $2) {\n        var n; // Named or numbered backreference with curly braces\n\n        if ($1) {\n          // XRegExp behavior for `${n}`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          n = +$1; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? indexOf(captureNames, $1) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError('Backreference to undefined group ' + $0);\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if ($2 === '$') {\n          // $$\n          return '$';\n        }\n\n        if ($2 === '&' || +$2 === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if ($2 === '`') {\n          // $` (left context)\n          return args[args.length - 1].slice(0, args[args.length - 2]);\n        }\n\n        if ($2 === \"'\") {\n          // $' (right context)\n          return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without curly braces\n\n\n        $2 = +$2; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN($2)) {\n          if ($2 > args.length - 3) {\n            throw new SyntaxError('Backreference to undefined group ' + $0);\n          }\n\n          return args[$2] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError('Invalid token ' + $0);\n      });\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`\n * uses this to override the native method. Use via `XRegExp.split` without overriding natives.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this),\n      output = [],\n      origLastIndex = separator.lastIndex,\n      lastLastIndex = 0,\n      lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  XRegExp.forEach(str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push(str.slice(lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, match.slice(1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push(str.slice(lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? output.slice(0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Invalid escape ' + match[0]);\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError('Invalid Unicode code point ' + match[0]);\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return '\\\\u' + pad4(hex(code));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && flags.indexOf('u') > -1) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, function (match) {\n  // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n  // (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n}, {\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, function (match, scope, flags) {\n  // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n  // inadvertedly changing `\\1(?#)1` to `\\11`.\n  return isQuantifierNext(match.input, match.index + match[0].length, flags) ? '' : '(?:)';\n}, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, function (match, scope, flags) {\n  // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n  // inadvertedly changing `\\1 1` to `\\11`.\n  return isQuantifierNext(match.input, match.index + match[0].length, flags) ? '' : '(?:)';\n}, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? indexOf(this.captureNames, match[1]) + 1 : +match[1],\n      endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError('Backreference to undefined group ' + match[0]);\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return '\\\\' + index + (endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' + match[0]);\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError('Cannot use integer as capture name ' + match[0]);\n  }\n\n  if (match[1] === 'length' || match[1] === '__proto__') {\n    throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);\n  }\n\n  if (indexOf(this.captureNames, match[1]) > -1) {\n    throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if (flags.indexOf('n') > -1) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nmodule.exports = XRegExp;","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/fuzzball/lib/xregexp/xregexp.js"],"names":["REGEX_DATA","features","astral","natives","nativ","exec","RegExp","prototype","test","match","String","replace","split","fixed","regexCache","patternCache","tokens","defaultScope","classScope","nativeTokens","replacementToken","correctExecNpcg","call","undefined","hasFlagsProp","flags","toString","hasNativeFlag","flag","isSupported","exception","hasNativeU","hasNativeY","registeredFlags","g","i","m","u","y","augment","regex","captureNames","xSource","xFlags","isInternalOnly","p","__proto__","XRegExp","source","sort","join","clipDuplicates","str","copyRegex","options","isRegExp","TypeError","xData","getNativeFlags","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","addG","addY","hasNamedCapture","slice","dec","hex","parseInt","indexOf","array","value","len","length","isType","type","isQuantifierNext","pattern","pos","pad4","prepareFlags","SyntaxError","$0","$1","charAt","registerFlag","Error","runTokens","scope","context","leadChar","result","t","matchLength","output","handler","reparse","setNatives","on","toObject","isInstalled","applied","appliedPattern","appliedFlags","token","captures","generated","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","optionalFlags","push","cache","flush","cacheName","sticky","cacheKey","fakeY","r2","lastIndex","pop","global","feature","search","replacement","isRegex","s2","escape","origLastIndex","apply","arguments","name","index","args","$2","n","isNaN","separator","limit","lastLastIndex","lastLength","forEach","Array","code","input","endIndex","module","exports"],"mappings":"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rH,KAAK,GAAGoH,EAAE,CAACC,SAAN,GAAkB,CAAzC;AACH;;AAED,SAAOrH,KAAP;AACH,CAlDD;AAoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAsC,OAAO,CAACwD,WAAR,GAAsB,UAAS0B,OAAT,EAAkB;AACpC,SAAO,CAAC,CAAEhI,QAAQ,CAACgI,OAAD,CAAlB;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlF,OAAO,CAACQ,QAAR,GAAmB,UAASmB,KAAT,EAAgB;AAC/B,SAAOhD,QAAQ,CAACJ,IAAT,CAAcoD,KAAd,MAAyB,iBAAhC,CAD+B,CAE/B;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3B,OAAO,CAACpC,OAAR,GAAkB,UAASyC,GAAT,EAAc8E,MAAd,EAAsBC,WAAtB,EAAmCxC,KAAnC,EAA0C;AACxD,MAAIyC,OAAO,GAAGrF,OAAO,CAACQ,QAAR,CAAiB2E,MAAjB,CAAd;AAAA,MACIF,MAAM,GAAIE,MAAM,CAACF,MAAP,IAAiBrC,KAAK,KAAK,KAA5B,IAAsCA,KAAK,KAAK,KAD7D;AAAA,MAEIgC,QAAQ,GAAI,CAACK,MAAM,GAAG,GAAH,GAAS,EAAhB,KAAuBE,MAAM,CAACR,MAAP,GAAgB,GAAhB,GAAsB,EAA7C,CAAD,IAAsD,MAFrE;AAAA,MAGIW,EAAE,GAAGH,MAHT;AAAA,MAIIpC,MAJJ;;AAMA,MAAIsC,OAAJ,EAAa;AACTF,IAAAA,MAAM,CAAClI,UAAD,CAAN,GAAqBkI,MAAM,CAAClI,UAAD,CAAN,IAAsB,EAA3C,CADS,CAGT;AACA;;AACAqI,IAAAA,EAAE,GAAGH,MAAM,CAAClI,UAAD,CAAN,CAAmB2H,QAAnB,MACDO,MAAM,CAAClI,UAAD,CAAN,CAAmB2H,QAAnB,IAA+BtE,SAAS,CAAC6E,MAAD,EAAS;AAC7CjE,MAAAA,IAAI,EAAE,CAAC,CAAC+D,MADqC;AAE7CjE,MAAAA,OAAO,EAAE4B,KAAK,KAAK,KAF0B;AAG7C/C,MAAAA,cAAc,EAAE;AAH6B,KAAT,CADvC,CAAL;AAOH,GAZD,MAYO,IAAIoF,MAAJ,EAAY;AACfK,IAAAA,EAAE,GAAG,IAAI/H,MAAJ,CAAWyC,OAAO,CAACuF,MAAR,CAAe5H,MAAM,CAACwH,MAAD,CAArB,CAAX,EAA2C,GAA3C,CAAL;AACH,GArBuD,CAuBxD;;;AACApC,EAAAA,MAAM,GAAGjF,KAAK,CAACF,OAAN,CAAcW,IAAd,CAAmBgF,QAAQ,CAAClD,GAAD,CAA3B,EAAkCiF,EAAlC,EAAsCF,WAAtC,CAAT;;AAEA,MAAIC,OAAO,IAAIF,MAAM,CAACF,MAAtB,EAA8B;AAC1B;AACAE,IAAAA,MAAM,CAACJ,SAAP,GAAmB,CAAnB;AACH;;AAED,SAAOhC,MAAP;AACH,CAhCD;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAG;AACH;AACA;AACA;AACA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","sourcesContent":["/*!\n * XRegExp 3.1.1-next\n * <xregexp.com>\n * Steven Levithan (c) 2007-2016 MIT License\n */\n\n'use strict';\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp';\n// Optional features that can be installed and uninstalled\nvar features = {\n    astral: false,\n    natives: false\n};\n// Native methods to use and restore ('native' is an ES3 reserved keyword)\nvar nativ = {\n    exec: RegExp.prototype.exec,\n    test: RegExp.prototype.test,\n    match: String.prototype.match,\n    replace: String.prototype.replace,\n    split: String.prototype.split\n};\n// Storage for fixed/extended native methods\nvar fixed = {};\n// Storage for regexes cached by `XRegExp.cache`\nvar regexCache = {};\n// Storage for pattern details cached by the `XRegExp` constructor\nvar patternCache = {};\n// Storage for regex syntax tokens added internally or by `XRegExp.addToken`\nvar tokens = [];\n// Token scopes\nvar defaultScope = 'default';\nvar classScope = 'class';\n// Regexes that match native regex syntax, including octals\nvar nativeTokens = {\n    // Any native multicharacter token in default scope, or any single character\n    'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n    // Any native multicharacter token in character class scope, or any single character\n    'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n};\n// Any backreference or dollar-prefixed character in replacement strings\nvar replacementToken = /\\$(?:{([\\w$]+)}|(\\d\\d?|[\\s\\S]))/g;\n// Check for correct `exec` handling of nonparticipating capturing groups\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;\n// Check for ES6 `flags` prop support\nvar hasFlagsProp = /x/.flags !== undefined;\n// Shortcut to `Object.prototype.toString`\nvar toString = {}.toString;\n\nfunction hasNativeFlag(flag) {\n    // Can't check based on the presence of properties/getters since browsers might support such\n    // properties even when they don't support the corresponding flag in regex construction (tested\n    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n    // throws an error)\n    var isSupported = true;\n    try {\n        // Can't use regex literals for testing even in a `try` because regex literals with\n        // unsupported flags cause a compilation error in IE\n        new RegExp('', flag);\n    } catch (exception) {\n        isSupported = false;\n    }\n    if (isSupported && flag === 'y') {\n        // Work around Safari 9.1.1 bug\n        return new RegExp('aa|.', 'y').test('b');\n    }\n    return isSupported;\n}\n// Check for ES6 `u` flag support\nvar hasNativeU = hasNativeFlag('u');\n// Check for ES6 `y` flag support\nvar hasNativeY = hasNativeFlag('y');\n// Tracker for known flags, including addon flags\nvar registeredFlags = {\n    g: true,\n    i: true,\n    m: true,\n    u: hasNativeU,\n    y: hasNativeY\n};\n\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n    var p;\n\n    regex[REGEX_DATA] = {\n        captureNames: captureNames\n    };\n\n    if (isInternalOnly) {\n        return regex;\n    }\n\n    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n    if (regex.__proto__) {\n        regex.__proto__ = XRegExp.prototype;\n    } else {\n        for (p in XRegExp.prototype) {\n            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n            // extensions exist on `regex.prototype` anyway\n            regex[p] = XRegExp.prototype[p];\n        }\n    }\n\n    regex[REGEX_DATA].source = xSource;\n    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n\n    return regex;\n}\n\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\nfunction clipDuplicates(str) {\n    return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`addG` {Boolean} Add flag g while copying the regex.\n *   <li>`addY` {Boolean} Add flag y while copying the regex.\n *   <li>`removeG` {Boolean} Remove flag g while copying the regex.\n *   <li>`removeY` {Boolean} Remove flag y while copying the regex.\n *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   <li>`source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\nfunction copyRegex(regex, options) {\n    if (!XRegExp.isRegExp(regex)) {\n        throw new TypeError('Type RegExp expected');\n    }\n\n    var xData = regex[REGEX_DATA] || {},\n        flags = getNativeFlags(regex),\n        flagsToAdd = '',\n        flagsToRemove = '',\n        xregexpSource = null,\n        xregexpFlags = null;\n\n    options = options || {};\n\n    if (options.removeG) {flagsToRemove += 'g';}\n    if (options.removeY) {flagsToRemove += 'y';}\n    if (flagsToRemove) {\n        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');\n    }\n\n    if (options.addG) {flagsToAdd += 'g';}\n    if (options.addY) {flagsToAdd += 'y';}\n    if (flagsToAdd) {\n        flags = clipDuplicates(flags + flagsToAdd);\n    }\n\n    if (!options.isInternalOnly) {\n        if (xData.source !== undefined) {\n            xregexpSource = xData.source;\n        }\n        // null or undefined; don't want to add to `flags` if the previous value was null, since\n        // that indicates we're not tracking original precompilation flags\n        if (xData.flags != null) {\n            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n            // removed for non-internal regexes, so don't need to handle it\n            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n        }\n    }\n\n    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n    // translation to native regex syntax\n    regex = augment(\n        new RegExp(options.source || regex.source, flags),\n        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,\n        xregexpSource,\n        xregexpFlags,\n        options.isInternalOnly\n    );\n\n    return regex;\n}\n\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */\nfunction dec(hex) {\n    return parseInt(hex, 16);\n}\n\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\nfunction getNativeFlags(regex) {\n    return hasFlagsProp ?\n        regex.flags :\n        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n        // with an empty string) allows this to continue working predictably when\n        // `XRegExp.proptotype.toString` is overridden\n        nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\nfunction hasNamedCapture(regex) {\n    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */\nfunction hex(dec) {\n    return parseInt(dec, 10).toString(16);\n}\n\n/**\n * Returns the first index at which a given value can be found in an array.\n *\n * @private\n * @param {Array} array Array to search.\n * @param {*} value Value to locate in the array.\n * @returns {Number} Zero-based index at which the item is found, or -1.\n */\nfunction indexOf(array, value) {\n    var len = array.length, i;\n\n    for (i = 0; i < len; ++i) {\n        if (array[i] === value) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\nfunction isType(value, type) {\n    return toString.call(value) === '[object ' + type + ']';\n}\n\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next token is a quantifier.\n */\nfunction isQuantifierNext(pattern, pos, flags) {\n    return nativ.test.call(\n        flags.indexOf('x') > -1 ?\n            // Ignore any leading whitespace, line comments, and inline comments\n            /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ :\n            // Ignore any leading inline comments\n            /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/,\n        pattern.slice(pos)\n    );\n}\n\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */\nfunction pad4(str) {\n    while (str.length < 4) {\n        str = '0' + str;\n    }\n    return str;\n}\n\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\nfunction prepareFlags(pattern, flags) {\n    var i;\n\n    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n    if (clipDuplicates(flags) !== flags) {\n        throw new SyntaxError('Invalid duplicate regex flag ' + flags);\n    }\n\n    // Strip and apply a leading mode modifier with any combination of flags except g or y\n    pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function($0, $1) {\n        if (nativ.test.call(/[gy]/, $1)) {\n            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);\n        }\n        // Allow duplicate flags within the mode modifier\n        flags = clipDuplicates(flags + $1);\n        return '';\n    });\n\n    // Throw on unknown native or nonnative flags\n    for (i = 0; i < flags.length; ++i) {\n        if (!registeredFlags[flags.charAt(i)]) {\n            throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));\n        }\n    }\n\n    return {\n        pattern: pattern,\n        flags: flags\n    };\n}\n\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n *//*\nfunction prepareOptions(value) {\n    var options = {};\n\n    if (isType(value, 'String')) {\n        XRegExp.forEach(value, /[^\\s,]+/, function(match) {\n            options[match] = true;\n        });\n\n        return options;\n    }\n\n    return value;\n}\n*/\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\nfunction registerFlag(flag) {\n    if (!/^[\\w$]$/.test(flag)) {\n        throw new Error('Flag must be a single character A-Za-z0-9_$');\n    }\n\n    registeredFlags[flag] = true;\n}\n\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\nfunction runTokens(pattern, flags, pos, scope, context) {\n    var i = tokens.length,\n        leadChar = pattern.charAt(pos),\n        result = null,\n        match,\n        t;\n\n    // Run in reverse insertion order\n    while (i--) {\n        t = tokens[i];\n        if (\n            (t.leadChar && t.leadChar !== leadChar) ||\n            (t.scope !== scope && t.scope !== 'all') ||\n            (t.flag && flags.indexOf(t.flag) === -1)\n        ) {\n            continue;\n        }\n\n        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n        if (match) {\n            result = {\n                matchLength: match[0].length,\n                output: t.handler.call(context, match, scope, flags),\n                reparse: t.reparse\n            };\n            // Finished with token tests\n            break;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n *//*\nfunction setAstral(on) {\n    features.astral = on;\n}\n*/\n/**\n * Enables or disables native method overrides.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\nfunction setNatives(on) {\n    RegExp.prototype.exec = (on ? fixed : nativ).exec;\n    RegExp.prototype.test = (on ? fixed : nativ).test;\n    String.prototype.match = (on ? fixed : nativ).match;\n    String.prototype.replace = (on ? fixed : nativ).replace;\n    String.prototype.split = (on ? fixed : nativ).split;\n\n    features.natives = on;\n}\n\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\nfunction toObject(value) {\n    // null or undefined\n    if (value == null) {\n        throw new TypeError('Cannot convert null or undefined to object');\n    }\n\n    return value;\n}\n\n// ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     <li>`g` - global\n *     <li>`i` - ignore case\n *     <li>`m` - multiline anchors\n *     <li>`u` - unicode (ES6)\n *     <li>`y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     <li>`n` - explicit capture\n *     <li>`s` - dot matches all (aka singleline)\n *     <li>`x` - free-spacing and line comments (aka extended)\n *     <li>`A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \\n\\\n *          (?<month> [0-9]{2} ) -?  # month \\n\\\n *          (?<day>   [0-9]{2} )     # day   ', 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\nfunction XRegExp(pattern, flags) {\n    if (XRegExp.isRegExp(pattern)) {\n        if (flags !== undefined) {\n            throw new TypeError('Cannot supply flags when copying a RegExp');\n        }\n        return copyRegex(pattern);\n    }\n\n    // Copy the argument behavior of `RegExp`\n    pattern = pattern === undefined ? '' : String(pattern);\n    flags = flags === undefined ? '' : String(flags);\n\n    if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {\n        // This causes an error to be thrown if the Unicode Base addon is not available\n        flags += 'A';\n    }\n\n    if (!patternCache[pattern]) {\n        patternCache[pattern] = {};\n    }\n\n    if (!patternCache[pattern][flags]) {\n        var context = {\n            hasNamedCapture: false,\n            captureNames: []\n        };\n        var scope = defaultScope;\n        var output = '';\n        var pos = 0;\n        var result;\n\n        // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n        var applied = prepareFlags(pattern, flags);\n        var appliedPattern = applied.pattern;\n        var appliedFlags = applied.flags;\n\n        // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n        // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n        while (pos < appliedPattern.length) {\n            do {\n                // Check for custom tokens at the current position\n                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);\n                // If the matched token used the `reparse` option, splice its output into the\n                // pattern before running tokens again at the same position\n                if (result && result.reparse) {\n                    appliedPattern = appliedPattern.slice(0, pos) +\n                        result.output +\n                        appliedPattern.slice(pos + result.matchLength);\n                }\n            } while (result && result.reparse);\n\n            if (result) {\n                output += result.output;\n                pos += (result.matchLength || 1);\n            } else {\n                // Get the native token at the current position\n                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];\n                output += token;\n                pos += token.length;\n                if (token === '[' && scope === defaultScope) {\n                    scope = classScope;\n                } else if (token === ']' && scope === classScope) {\n                    scope = defaultScope;\n                }\n            }\n        }\n\n        patternCache[pattern][flags] = {\n            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n            // groups are sometimes inserted during regex transpilation in order to keep tokens\n            // separated. However, more than one empty group in a row is never needed.\n            pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n            // Strip all but native flags\n            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n            // `context.captureNames` has an item for each capturing group, even if unnamed\n            captures: context.hasNamedCapture ? context.captureNames : null\n        };\n    }\n\n    var generated = patternCache[pattern][flags];\n    return augment(\n        new RegExp(generated.pattern, generated.flags),\n        generated.captures,\n        pattern,\n        flags\n    );\n}\n\n// Add `RegExp.prototype` to the prototype chain\nXRegExp.prototype = new RegExp();\n\n// ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\nXRegExp.version = '3.1.1-next';\n\n// ==--------------------------==\n// Public methods\n// ==--------------------------==\n\n// Intentionally undocumented; used in tests and addons\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The regex scope where the match was found: 'default' or 'class'.\n *   <li>The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   function() {return '\\\\x07';},\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   function(match) {return match[1] + (match[2] ? '' : '?');},\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\nXRegExp.addToken = function(regex, handler, options) {\n    options = options || {};\n    var optionalFlags = options.optionalFlags, i;\n\n    if (options.flag) {\n        registerFlag(options.flag);\n    }\n\n    if (optionalFlags) {\n        optionalFlags = nativ.split.call(optionalFlags, '');\n        for (i = 0; i < optionalFlags.length; ++i) {\n            registerFlag(optionalFlags[i]);\n        }\n    }\n\n    // Add to the private list of syntax tokens\n    tokens.push({\n        regex: copyRegex(regex, {\n            addG: true,\n            addY: hasNativeY,\n            isInternalOnly: true\n        }),\n        handler: handler,\n        scope: options.scope || defaultScope,\n        flag: options.flag,\n        reparse: options.reparse,\n        leadChar: options.leadChar\n    });\n\n    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n    // might now produce different results\n    XRegExp.cache.flush('patterns');\n};\n\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\nXRegExp.cache = function(pattern, flags) {\n    if (!regexCache[pattern]) {\n        regexCache[pattern] = {};\n    }\n    return regexCache[pattern][flags] || (\n        regexCache[pattern][flags] = XRegExp(pattern, flags)\n    );\n};\n\n// Intentionally undocumented; used in tests\nXRegExp.cache.flush = function(cacheName) {\n    if (cacheName === 'patterns') {\n        // Flush the pattern cache used by the `XRegExp` constructor\n        patternCache = {};\n    } else {\n        // Flush the regex cache populated by `XRegExp.cache`\n        regexCache = {};\n    }\n};\n\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n *//*\nXRegExp.escape = function(str) {\n    return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n*/\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * var match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * var pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\nXRegExp.exec = function(str, regex, pos, sticky) {\n    var cacheKey = 'g',\n        addY = false,\n        fakeY = false,\n        match,\n        r2;\n\n    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));\n    if (addY) {\n        cacheKey += 'y';\n    } else if (sticky) {\n        // Simulate sticky matching by appending an empty capture to the original regex. The\n        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n        // and will not search the rest of the subject string. We'll know that the original regex\n        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n        // capture participated in the match).\n        fakeY = true;\n        cacheKey += 'FakeY';\n    }\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.match`/`replace`\n    r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: true,\n            addY: addY,\n            source: fakeY ? regex.source + '|()' : undefined,\n            removeY: sticky === false,\n            isInternalOnly: true\n        })\n    );\n\n    pos = pos || 0;\n    r2.lastIndex = pos;\n\n    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n    match = fixed.exec.call(r2, str);\n\n    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n    // the original regexp failed (see above).\n    if (fakeY && match && match.pop() === '') {\n        match = null;\n    }\n\n    if (regex.global) {\n        regex.lastIndex = match ? r2.lastIndex : 0;\n    }\n\n    return match;\n};\n\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The zero-based match index.\n *   <li>The string being traversed.\n *   <li>The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * var evens = [];\n * XRegExp.forEach('1a2345', /\\d/, function(match, i) {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n *//*\nXRegExp.forEach = function(str, regex, callback) {\n    var pos = 0,\n        i = -1,\n        match;\n\n    while ((match = XRegExp.exec(str, regex, pos))) {\n        // Because `regex` is provided to `callback`, the function could use the deprecated/\n        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n        // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n        // which is a nice side effect that brings extra safety.\n        callback(match, ++i, str, regex);\n\n        pos = match.index + (match[0].length || 1);\n    }\n};\n*/\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * var globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n *//*\nXRegExp.globalize = function(regex) {\n    return copyRegex(regex, {addG: true});\n};\n*/\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // DEPRECATED: Overrides native regex methods with fixed/extended versions\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral natives');\n *//*\nXRegExp.install = function(options) {\n    options = prepareOptions(options);\n\n    if (!features.astral && options.astral) {\n        setAstral(true);\n    }\n\n    if (!features.natives && options.natives) {\n        setNatives(true);\n    }\n};\n*/\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   <li>`astral`\n *   <li>`natives`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\nXRegExp.isInstalled = function(feature) {\n    return !!(features[feature]);\n};\n\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\nXRegExp.isRegExp = function(value) {\n    return toString.call(value) === '[object RegExp]';\n    //return isType(value, 'RegExp');\n};\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n *//*\nXRegExp.match = function(str, regex, scope) {\n    var global = (regex.global && scope !== 'one') || scope === 'all',\n        cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',\n        result,\n        r2;\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.exec`/`replace`\n    r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: !!global,\n            removeG: scope === 'one',\n            isInternalOnly: true\n        })\n    );\n\n    result = nativ.match.call(toObject(str), r2);\n\n    if (regex.global) {\n        regex.lastIndex = (\n            (scope === 'one' && result) ?\n                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n                (result.index + result[0].length) : 0\n        );\n    }\n\n    return global ? (result || []) : (result && result[0]);\n};\n*/\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n/*XRegExp.matchChain = function(str, chain) {\n    return (function recurseChain(values, level) {\n        var item = chain[level].regex ? chain[level] : {regex: chain[level]};\n        var matches = [];\n\n        function addMatch(match) {\n            if (item.backref) {\n                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the\n                // `undefined`s for backreferences to nonparticipating capturing groups. In such\n                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw\n                // the exception, so also check if the backreference is a number that is within the\n                // bounds of the array.\n                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {\n                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);\n                }\n\n                matches.push(match[item.backref] || '');\n            } else {\n                matches.push(match[0]);\n            }\n        }\n\n        for (var i = 0; i < values.length; ++i) {\n            XRegExp.forEach(values[i], item.regex, addMatch);\n        }\n\n        return ((level === chain.length - 1) || !matches.length) ?\n            matches :\n            recurseChain(matches, level + 1);\n    }([str], 0));\n};\n*/\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement\n * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared\n * to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     <li>$$ - Inserts a literal $ character.\n *     <li>$&, $0 - Inserts the matched substring.\n *     <li>$` - Inserts the string that precedes the matched substring (left context).\n *     <li>$' - Inserts the string that follows the matched substring (right context).\n *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     <li>The zero-based index of the match within the total search string.\n *     <li>The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * var name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '${last}, ${first}');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, function(match) {\n *   return match.last + ', ' + match.first;\n * });\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\nXRegExp.replace = function(str, search, replacement, scope) {\n    var isRegex = XRegExp.isRegExp(search),\n        global = (search.global && scope !== 'one') || scope === 'all',\n        cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',\n        s2 = search,\n        result;\n\n    if (isRegex) {\n        search[REGEX_DATA] = search[REGEX_DATA] || {};\n\n        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n        // `lastIndex` isn't updated *during* replacement iterations\n        s2 = search[REGEX_DATA][cacheKey] || (\n            search[REGEX_DATA][cacheKey] = copyRegex(search, {\n                addG: !!global,\n                removeG: scope === 'one',\n                isInternalOnly: true\n            })\n        );\n    } else if (global) {\n        s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n    }\n\n    // Fixed `replace` required for named backreferences, etc.\n    result = fixed.replace.call(toObject(str), s2, replacement);\n\n    if (isRegex && search.global) {\n        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n        search.lastIndex = 0;\n    }\n\n    return result;\n};\n\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, function($0) {\n *     return $0.toUpperCase();\n *   }]\n * ]);\n *//*\nXRegExp.replaceEach = function(str, replacements) {\n    var i, r;\n\n    for (i = 0; i < replacements.length; ++i) {\n        r = replacements[i];\n        str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n\n    return str;\n};\n*/\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n *//*\nXRegExp.split = function(str, separator, limit) {\n    return fixed.split.call(toObject(str), separator, limit);\n};\n*/\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n/*XRegExp.test = function(str, regex, pos, sticky) {\n    // Do this the easy way :-)\n    return !!XRegExp.exec(str, regex, pos, sticky);\n};\n*/\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // DEPRECATED: Restores native regex methods\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral natives');\n *//*\nXRegExp.uninstall = function(options) {\n    options = prepareOptions(options);\n\n    if (features.astral && options.astral) {\n        setAstral(false);\n    }\n\n    if (features.natives && options.natives) {\n        setNatives(false);\n    }\n};\n*/\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *//*\nXRegExp.union = function(patterns, flags) {\n    var numCaptures = 0;\n    var numPriorCaptures;\n    var captureNames;\n\n    function rewrite(match, paren, backref) {\n        var name = captureNames[numCaptures - numPriorCaptures];\n\n        // Capturing group\n        if (paren) {\n            ++numCaptures;\n            // If the current capture has a name, preserve the name\n            if (name) {\n                return '(?<' + name + '>';\n            }\n        // Backreference\n        } else if (backref) {\n            // Rewrite the backreference\n            return '\\\\' + (+backref + numPriorCaptures);\n        }\n\n        return match;\n    }\n\n    if (!(isType(patterns, 'Array') && patterns.length)) {\n        throw new TypeError('Must provide a nonempty array of patterns to merge');\n    }\n\n    var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n    var output = [];\n    var pattern;\n    for (var i = 0; i < patterns.length; ++i) {\n        pattern = patterns[i];\n\n        if (XRegExp.isRegExp(pattern)) {\n            numPriorCaptures = numCaptures;\n            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];\n\n            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n            // independently valid; helps keep this simple. Named captures are put back\n            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n        } else {\n            output.push(XRegExp.escape(pattern));\n        }\n    }\n\n    return XRegExp(output.join('|'), flags);\n};\n*/\n// ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to\n * override the native method. Use via `XRegExp.exec` without overriding natives.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\nfixed.exec = function(str) {\n    var origLastIndex = this.lastIndex,\n        match = nativ.exec.apply(this, arguments),\n        name,\n        r2,\n        i;\n\n    if (match) {\n        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n        // in standards mode follows the spec.\n        if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {\n            r2 = copyRegex(this, {\n                removeG: true,\n                isInternalOnly: true\n            });\n            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n            // matching due to characters outside the match\n            nativ.replace.call(String(str).slice(match.index), r2, function() {\n                var len = arguments.length, i;\n                // Skip index 0 and the last 2\n                for (i = 1; i < len - 2; ++i) {\n                    if (arguments[i] === undefined) {\n                        match[i] = undefined;\n                    }\n                }\n            });\n        }\n\n        // Attach named capture properties\n        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n            // Skip index 0\n            for (i = 1; i < match.length; ++i) {\n                name = this[REGEX_DATA].captureNames[i - 1];\n                if (name) {\n                    match[name] = match[i];\n                }\n            }\n        }\n\n        // Fix browsers that increment `lastIndex` after zero-length matches\n        if (this.global && !match[0].length && (this.lastIndex > match.index)) {\n            this.lastIndex = match.index;\n        }\n    }\n\n    if (!this.global) {\n        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n        this.lastIndex = origLastIndex;\n    }\n\n    return match;\n};\n\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`\n * uses this to override the native method.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\n/*fixed.test = function(str) {\n    // Do this the easy way :-)\n    return !!fixed.exec.call(this, str);\n};*/\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to\n * override the native method.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n/*fixed.match = function(regex) {\n    var result;\n\n    if (!XRegExp.isRegExp(regex)) {\n        // Use the native `RegExp` rather than `XRegExp`\n        regex = new RegExp(regex);\n    } else if (regex.global) {\n        result = nativ.match.apply(this, arguments);\n        // Fixes IE bug\n        regex.lastIndex = 0;\n\n        return result;\n    }\n\n    return fixed.exec.call(regex, toObject(this));\n};\n*/\n/**\n * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and\n * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser\n * bugs in replacement text syntax when performing a replacement using a nonregex search value, and\n * the value of a replacement regex's `lastIndex` property during replacement iterations and upon\n * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note\n * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via\n * `XRegExp.replace` without overriding natives.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\nfixed.replace = function(search, replacement) {\n    var isRegex = XRegExp.isRegExp(search),\n        origLastIndex,\n        captureNames,\n        result;\n\n    if (isRegex) {\n        if (search[REGEX_DATA]) {\n            captureNames = search[REGEX_DATA].captureNames;\n        }\n        // Only needed if `search` is nonglobal\n        origLastIndex = search.lastIndex;\n    } else {\n        search += ''; // Type-convert\n    }\n\n    // Don't use `typeof`; some older browsers return 'function' for regex objects\n    if (isType(replacement, 'Function')) {\n        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n        // functions isn't type-converted to a string\n        result = nativ.replace.call(String(this), search, function() {\n            var args = arguments, i;\n            if (captureNames) {\n                // Change the `arguments[0]` string primitive to a `String` object that can store\n                // properties. This really does need to use `String` as a constructor\n                args[0] = new String(args[0]);\n                // Store named backreferences on the first argument\n                for (i = 0; i < captureNames.length; ++i) {\n                    if (captureNames[i]) {\n                        args[0][captureNames[i]] = args[i + 1];\n                    }\n                }\n            }\n            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n            if (isRegex && search.global) {\n                search.lastIndex = args[args.length - 2] + args[0].length;\n            }\n            // ES6 specs the context for replacement functions as `undefined`\n            return replacement.apply(undefined, args);\n        });\n    } else {\n        // Ensure that the last value of `args` will be a string when given nonstring `this`,\n        // while still throwing on null or undefined context\n        result = nativ.replace.call(this == null ? this : String(this), search, function() {\n            // Keep this function's `arguments` available through closure\n            var args = arguments;\n            return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {\n                var n;\n                // Named or numbered backreference with curly braces\n                if ($1) {\n                    // XRegExp behavior for `${n}`:\n                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n                    //    entire match. Any number of leading zeros may be used.\n                    // 2. Backreference to named capture `n`, if it exists and is not an integer\n                    //    overridden by numbered capture. In practice, this does not overlap with\n                    //    numbered capture since XRegExp does not allow named capture to use a bare\n                    //    integer as the name.\n                    // 3. If the name or number does not refer to an existing capturing group, it's\n                    //    an error.\n                    n = +$1; // Type-convert; drop leading zeros\n                    if (n <= args.length - 3) {\n                        return args[n] || '';\n                    }\n                    // Groups with the same name is an error, else would need `lastIndexOf`\n                    n = captureNames ? indexOf(captureNames, $1) : -1;\n                    if (n < 0) {\n                        throw new SyntaxError('Backreference to undefined group ' + $0);\n                    }\n                    return args[n + 1] || '';\n                }\n                // Else, special variable or numbered backreference without curly braces\n                if ($2 === '$') { // $$\n                    return '$';\n                }\n                if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00\n                    return args[0];\n                }\n                if ($2 === '`') { // $` (left context)\n                    return args[args.length - 1].slice(0, args[args.length - 2]);\n                }\n                if ($2 === \"'\") { // $' (right context)\n                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n                }\n                // Else, numbered backreference without curly braces\n                $2 = +$2; // Type-convert; drop leading zero\n                // XRegExp behavior for `$n` and `$nn`:\n                // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.\n                // - `$1` is an error if no capturing groups.\n                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.\n                // - `$01` is `$1` if at least one capturing group, else it's an error.\n                // - `$0` (not followed by 1-9) and `$00` are the entire match.\n                // Native behavior, for comparison:\n                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n                // - `$1` is a literal `$1` if no capturing groups.\n                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n                // - `$0` is a literal `$0`.\n                if (!isNaN($2)) {\n                    if ($2 > args.length - 3) {\n                        throw new SyntaxError('Backreference to undefined group ' + $0);\n                    }\n                    return args[$2] || '';\n                }\n                // `$` followed by an unsupported char is an error, unlike native JS\n                throw new SyntaxError('Invalid token ' + $0);\n            });\n        });\n    }\n\n    if (isRegex) {\n        if (search.global) {\n            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n            search.lastIndex = 0;\n        } else {\n            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n            search.lastIndex = origLastIndex;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`\n * uses this to override the native method. Use via `XRegExp.split` without overriding natives.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\nfixed.split = function(separator, limit) {\n    if (!XRegExp.isRegExp(separator)) {\n        // Browsers handle nonregex split correctly, so use the faster native method\n        return nativ.split.apply(this, arguments);\n    }\n\n    var str = String(this),\n        output = [],\n        origLastIndex = separator.lastIndex,\n        lastLastIndex = 0,\n        lastLength;\n\n    // Values for `limit`, per the spec:\n    // If undefined: pow(2,32) - 1\n    // If 0, Infinity, or NaN: 0\n    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n    // If negative number: pow(2,32) - floor(abs(limit))\n    // If other: Type-convert, then use the above rules\n    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n    limit = (limit === undefined ? -1 : limit) >>> 0;\n\n    XRegExp.forEach(str, separator, function(match) {\n        // This condition is not the same as `if (match[0].length)`\n        if ((match.index + match[0].length) > lastLastIndex) {\n            output.push(str.slice(lastLastIndex, match.index));\n            if (match.length > 1 && match.index < str.length) {\n                Array.prototype.push.apply(output, match.slice(1));\n            }\n            lastLength = match[0].length;\n            lastLastIndex = match.index + lastLength;\n        }\n    });\n\n    if (lastLastIndex === str.length) {\n        if (!nativ.test.call(separator, '') || lastLength) {\n            output.push('');\n        }\n    } else {\n        output.push(str.slice(lastLastIndex));\n    }\n\n    separator.lastIndex = origLastIndex;\n    return output.length > limit ? output.slice(0, limit) : output;\n};\n\n// ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\nXRegExp.addToken(\n    /\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,\n    function(match, scope) {\n        // \\B is allowed in default scope only\n        if (match[1] === 'B' && scope === defaultScope) {\n            return match[0];\n        }\n        throw new SyntaxError('Invalid escape ' + match[0]);\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\nXRegExp.addToken(\n    /\\\\u{([\\dA-Fa-f]+)}/,\n    function(match, scope, flags) {\n        var code = dec(match[1]);\n        if (code > 0x10FFFF) {\n            throw new SyntaxError('Invalid Unicode code point ' + match[0]);\n        }\n        if (code <= 0xFFFF) {\n            // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n            // separate from preceding tokens\n            return '\\\\u' + pad4(hex(code));\n        }\n        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n        if (hasNativeU && flags.indexOf('u') > -1) {\n            return match[0];\n        }\n        throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\nXRegExp.addToken(\n    /\\[(\\^?)\\]/,\n    function(match) {\n        // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n        // (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n        return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n    },\n    {leadChar: '['}\n);\n\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\nXRegExp.addToken(\n    /\\(\\?#[^)]*\\)/,\n    function(match, scope, flags) {\n        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n        // inadvertedly changing `\\1(?#)1` to `\\11`.\n        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?\n            '' : '(?:)';\n    },\n    {leadChar: '('}\n);\n\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\nXRegExp.addToken(\n    /\\s+|#[^\\n]*\\n?/,\n    function(match, scope, flags) {\n        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n        // inadvertedly changing `\\1 1` to `\\11`.\n        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?\n            '' : '(?:)';\n    },\n    {flag: 'x'}\n);\n\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\nXRegExp.addToken(\n    /\\./,\n    function() {\n        return '[\\\\s\\\\S]';\n    },\n    {\n        flag: 's',\n        leadChar: '.'\n    }\n);\n\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\nXRegExp.addToken(\n    /\\\\k<([\\w$]+)>/,\n    function(match) {\n        // Groups with the same name is an error, else would need `lastIndexOf`\n        var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],\n            endIndex = match.index + match[0].length;\n        if (!index || index > this.captureNames.length) {\n            throw new SyntaxError('Backreference to undefined group ' + match[0]);\n        }\n        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n        // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n        return '\\\\' + index + (\n            endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?\n                '' : '(?:)'\n        );\n    },\n    {leadChar: '\\\\'}\n);\n\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\nXRegExp.addToken(\n    /\\\\(\\d+)/,\n    function(match, scope) {\n        if (\n            !(\n                scope === defaultScope &&\n                /^[1-9]/.test(match[1]) &&\n                +match[1] <= this.captureNames.length\n            ) &&\n            match[1] !== '0'\n        ) {\n            throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +\n                match[0]);\n        }\n        return match[0];\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\nXRegExp.addToken(\n    /\\(\\?P?<([\\w$]+)>/,\n    function(match) {\n        // Disallow bare integers as names because named backreferences are added to match arrays\n        // and therefore numeric properties may lead to incorrect lookups\n        if (!isNaN(match[1])) {\n            throw new SyntaxError('Cannot use integer as capture name ' + match[0]);\n        }\n        if (match[1] === 'length' || match[1] === '__proto__') {\n            throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);\n        }\n        if (indexOf(this.captureNames, match[1]) > -1) {\n            throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);\n        }\n        this.captureNames.push(match[1]);\n        this.hasNamedCapture = true;\n        return '(';\n    },\n    {leadChar: '('}\n);\n\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\nXRegExp.addToken(\n    /\\((?!\\?)/,\n    function(match, scope, flags) {\n        if (flags.indexOf('n') > -1) {\n            return '(?:';\n        }\n        this.captureNames.push(null);\n        return '(';\n    },\n    {\n        optionalFlags: 'n',\n        leadChar: '('\n    }\n);\n\nmodule.exports = XRegExp;\n"]},"metadata":{},"sourceType":"script"}