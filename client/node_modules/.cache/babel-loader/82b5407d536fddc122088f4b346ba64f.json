{"ast":null,"code":"/*!\n * XRegExp Unicode Base 3.1.1-next\n * <xregexp.com>\n * Steven Levithan (c) 2008-2016 MIT License\n */\nmodule.exports = function (XRegExp) {\n  'use strict';\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr.charAt(0) === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    XRegExp.forEach(range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\" + pad4(hex(lastEnd + 1));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\" + pad4(hex(start - 1));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\" + pad4(hex(lastEnd + 1));\n\n      if (lastEnd < 0xFFFE) {\n        output += \"-\\\\uFFFF\";\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  }\n  /*\n      // Combines and optionally negates BMP and astral data\n      function buildAstral(slug, isNegated) {\n          var item = unicode[slug];\n          var combined = '';\n  \n          if (item.bmp && !item.isBmpLast) {\n              combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');\n          }\n          if (item.astral) {\n              combined += item.astral;\n          }\n          if (item.isBmpLast && item.bmp) {\n              combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';\n          }\n  \n          // Astral Unicode tokens always match a code point, never a code unit\n          return isNegated ?\n              '(?:(?!' + combined + ')(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))' :\n              '(?:' + combined + ')';\n      }\n  \n      // Builds a complete astral pattern on first use\n      function cacheAstral(slug, isNegated) {\n          var prop = isNegated ? 'a!' : 'a=';\n          return (\n              unicode[slug][prop] ||\n              (unicode[slug][prop] = buildAstral(slug, isNegated))\n          );\n      }\n  */\n  // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n    // var isAstralMode = flags.indexOf('A') > -1;\n    // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!item.bmp\n    /*|| isAstralMode*/\n    ) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n    /*           if (isAstralMode) {\n                   if (scope === 'class') {\n                       throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n                   }\n                    return cacheAstral(slug, isNegated);\n               }\n    */\n\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? '[^' : '[') + item.bmp + ']';\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n    var item;\n\n    for (var i = 0; i < data.length; ++i) {\n      item = data[i];\n\n      if (!item.name) {\n        throw new Error(ERR_NO_NAME);\n      }\n\n      if (!(item.inverseOf || item.bmp || item.astral)) {\n        throw new Error(ERR_NO_DATA + item.name);\n      }\n\n      unicode[normalize(item.name)] = item;\n\n      if (item.alias) {\n        unicode[normalize(item.alias)] = item;\n      }\n    } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n    // flags might now produce different results\n\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/fuzzball/lib/xregexp/unicode-base.js"],"names":["module","exports","XRegExp","unicode","dec","_dec","hex","_hex","pad4","_pad4","normalize","name","replace","toLowerCase","charCode","chr","esc","exec","charCodeAt","charAt","invertBmp","range","output","lastEnd","forEach","m","start","cacheInvertedBmp","slug","prop","bmp","addToken","match","scope","flags","ERR_DOUBLE_NEG","ERR_UNKNOWN_NAME","ERR_UNKNOWN_REF","ERR_ASTRAL_ONLY","ERR_ASTRAL_IN_CLASS","isNegated","item","SyntaxError","hasOwnProperty","inverseOf","ReferenceError","optionalFlags","leadChar","addUnicodeData","data","ERR_NO_NAME","ERR_NO_DATA","i","length","Error","astral","alias","cache","flush","_getUnicodeProperty"],"mappings":"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","sourcesContent":["/*!\n * XRegExp Unicode Base 3.1.1-next\n * <xregexp.com>\n * Steven Levithan (c) 2008-2016 MIT License\n */\n\nmodule.exports = function(XRegExp) {\n    'use strict';\n\n    /**\n     * Adds base support for Unicode matching:\n     * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n     *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n     *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n     * - Adds flag A (astral), which enables 21-bit Unicode support.\n     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n     *\n     * Unicode Base relies on externally provided Unicode character data. Official addons are\n     * available to provide data for Unicode categories, scripts, blocks, and properties.\n     *\n     * @requires XRegExp\n     */\n\n    // ==--------------------------==\n    // Private stuff\n    // ==--------------------------==\n\n    // Storage for Unicode data\n    var unicode = {};\n\n    // Reuse utils\n    var dec = XRegExp._dec;\n    var hex = XRegExp._hex;\n    var pad4 = XRegExp._pad4;\n\n    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n    function normalize(name) {\n        return name.replace(/[- _]+/g, '').toLowerCase();\n    }\n\n    // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n    function charCode(chr) {\n        var esc = /^\\\\[xu](.+)/.exec(chr);\n        return esc ?\n            dec(esc[1]) :\n            chr.charCodeAt(chr.charAt(0) === '\\\\' ? 1 : 0);\n    }\n\n    // Inverts a list of ordered BMP characters and ranges\n    function invertBmp(range) {\n        var output = '';\n        var lastEnd = -1;\n\n        XRegExp.forEach(\n            range,\n            /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,\n            function(m) {\n                var start = charCode(m[1]);\n                if (start > (lastEnd + 1)) {\n                    output += '\\\\u' + pad4(hex(lastEnd + 1));\n                    if (start > (lastEnd + 2)) {\n                        output += '-\\\\u' + pad4(hex(start - 1));\n                    }\n                }\n                lastEnd = charCode(m[2] || m[1]);\n            }\n        );\n\n        if (lastEnd < 0xFFFF) {\n            output += '\\\\u' + pad4(hex(lastEnd + 1));\n            if (lastEnd < 0xFFFE) {\n                output += '-\\\\uFFFF';\n            }\n        }\n\n        return output;\n    }\n\n    // Generates an inverted BMP range on first use\n    function cacheInvertedBmp(slug) {\n        var prop = 'b!';\n        return (\n            unicode[slug][prop] ||\n            (unicode[slug][prop] = invertBmp(unicode[slug].bmp))\n        );\n    }\n/*\n    // Combines and optionally negates BMP and astral data\n    function buildAstral(slug, isNegated) {\n        var item = unicode[slug];\n        var combined = '';\n\n        if (item.bmp && !item.isBmpLast) {\n            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');\n        }\n        if (item.astral) {\n            combined += item.astral;\n        }\n        if (item.isBmpLast && item.bmp) {\n            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';\n        }\n\n        // Astral Unicode tokens always match a code point, never a code unit\n        return isNegated ?\n            '(?:(?!' + combined + ')(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))' :\n            '(?:' + combined + ')';\n    }\n\n    // Builds a complete astral pattern on first use\n    function cacheAstral(slug, isNegated) {\n        var prop = isNegated ? 'a!' : 'a=';\n        return (\n            unicode[slug][prop] ||\n            (unicode[slug][prop] = buildAstral(slug, isNegated))\n        );\n    }\n*/\n    // ==--------------------------==\n    // Core functionality\n    // ==--------------------------==\n\n    /*\n     * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n     */\n    XRegExp.addToken(\n        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n        /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,\n        function(match, scope, flags) {\n            var ERR_DOUBLE_NEG = 'Invalid double negation ';\n            var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n            var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n            var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n            var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';\n            // Negated via \\P{..} or \\p{^..}\n            var isNegated = match[1] === 'P' || !!match[2];\n            // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n           // var isAstralMode = flags.indexOf('A') > -1;\n            // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n            var slug = normalize(match[4] || match[3]);\n            // Token data object\n            var item = unicode[slug];\n\n            if (match[1] === 'P' && match[2]) {\n                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n            }\n            if (!unicode.hasOwnProperty(slug)) {\n                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n            }\n\n            // Switch to the negated form of the referenced Unicode token\n            if (item.inverseOf) {\n                slug = normalize(item.inverseOf);\n                if (!unicode.hasOwnProperty(slug)) {\n                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);\n                }\n                item = unicode[slug];\n                isNegated = !isNegated;\n            }\n\n            if (!(item.bmp /*|| isAstralMode*/)) {\n                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n            }\n /*           if (isAstralMode) {\n                if (scope === 'class') {\n                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n                }\n\n                return cacheAstral(slug, isNegated);\n            }\n*/\n            return scope === 'class' ?\n                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :\n                (isNegated ? '[^' : '[') + item.bmp + ']';\n        },\n        {\n            scope: 'all',\n            optionalFlags: 'A',\n            leadChar: '\\\\'\n        }\n    );\n\n    /**\n     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n     *\n     * @memberOf XRegExp\n     * @param {Array} data Objects with named character ranges. Each object may have properties\n     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n     *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n     *   character classes and alternation, and should use surrogate pairs to represent astral code\n     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n     *   defined as the exact inverse of another token.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.addUnicodeData([{\n     *   name: 'XDigit',\n     *   alias: 'Hexadecimal',\n     *   bmp: '0-9A-Fa-f'\n     * }]);\n     * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n     */\n    XRegExp.addUnicodeData = function(data) {\n        var ERR_NO_NAME = 'Unicode token requires name';\n        var ERR_NO_DATA = 'Unicode token has no character data ';\n        var item;\n\n        for (var i = 0; i < data.length; ++i) {\n            item = data[i];\n            if (!item.name) {\n                throw new Error(ERR_NO_NAME);\n            }\n            if (!(item.inverseOf || item.bmp || item.astral)) {\n                throw new Error(ERR_NO_DATA + item.name);\n            }\n            unicode[normalize(item.name)] = item;\n            if (item.alias) {\n                unicode[normalize(item.alias)] = item;\n            }\n        }\n\n        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n        // flags might now produce different results\n        XRegExp.cache.flush('patterns');\n    };\n\n    /**\n     * @ignore\n     *\n     * Return a reference to the internal Unicode definition structure for the given Unicode\n     * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n     * constructs.\n     *\n     * @memberOf XRegExp\n     * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n     *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n     *   Properties and Property Aliases.\n     * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n     *\n     * @note\n     * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n     *\n     * @note\n     * This method is *not* part of the officially documented API and may change or be removed in\n     * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n     * structures set up by XRegExp.\n     */\n    XRegExp._getUnicodeProperty = function(name) {\n        var slug = normalize(name);\n        return unicode[slug];\n    };\n\n};\n"]},"metadata":{},"sourceType":"script"}