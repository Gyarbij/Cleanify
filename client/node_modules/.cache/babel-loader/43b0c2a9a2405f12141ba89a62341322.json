{"ast":null,"code":"import axios from \"axios\";\nconst instance = axios.create();\n\nconst wait = next_retry_time => new Promise(res => setTimeout(res, next_retry_time * 1000));\n\ninstance.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"api-key\");\n  console.log(\"token\", token);\n\n  if (token) {\n    config.headers = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n  }\n\n  return config;\n});\ninstance.interceptors.response.use(response => response.data, async error => {\n  if (error.response.status === 429) {\n    const next_retry_time = error.response.headers[\"retry-after\"];\n    console.log(\"Rate limited, retry after\", next_retry_time);\n\n    if (next_retry_time) {\n      wait(next_retry_time);\n      return instance.request(error.config);\n    }\n  }\n\n  console.log(\"API ERROR\", error);\n  Promise.reject(error);\n});\nexport const getUser = () => handleResponse(instance.get(\"https://api.spotify.com/v1/me\"));\nexport const getPlaylists = () => handleResponse(instance.get(\"https://api.spotify.com/v1/me/playlists\"));\nexport const getTracks = playlistID => handleResponse(instance.get(`https://api.spotify.com/v1/playlists/${playlistID}/tracks`));\nexport const getNextTracks = next => handleResponse(instance.get(next));\nexport const createPlaylist = (playlistName, userId) => handleResponse(instance.post(`https://api.spotify.com/v1/users/${userId}/playlists`, {\n  name: playlistName,\n  public: false\n}));\nexport const deletePlaylist = playlistID => handleResponse(instance.delete(`https://api.spotify.com/v1/playlists/${playlistID}/followers`));\nexport const addTracksToPlaylist = (playlistID, trackIDs) => handleResponse(instance.post(`https://api.spotify.com/v1/playlists/${playlistID}/tracks`, {\n  uris: trackIDs\n}));\nexport const searchForTracks = trackName => {\n  return handleResponse(instance.get(`https://api.spotify.com/v1/search?q=${trackName}&type=track`));\n};\n\nclass APIError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"APIError\";\n  }\n\n}\n\nconst handleResponse = request => request.then(res => {\n  return res;\n}).catch(error => {\n  var _error$response;\n\n  const message = (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data.error;\n\n  if (message) {\n    console.error(\"APIError:\", message, error);\n\n    if (message === \"Invalid access token\") {\n      localStorage.removeItem(\"api-key\");\n    }\n\n    return new APIError({ ...error,\n      message\n    });\n  } else {\n    return error;\n  }\n});","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/src/utils/api.js"],"names":["axios","instance","create","wait","next_retry_time","Promise","res","setTimeout","interceptors","request","use","config","token","localStorage","getItem","console","log","headers","Authorization","response","data","error","status","reject","getUser","handleResponse","get","getPlaylists","getTracks","playlistID","getNextTracks","next","createPlaylist","playlistName","userId","post","name","public","deletePlaylist","delete","addTracksToPlaylist","trackIDs","uris","searchForTracks","trackName","APIError","Error","then","catch","message","removeItem"],"mappings":"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","sourcesContent":["import axios from \"axios\";\n\nconst instance = axios.create();\nconst wait = (next_retry_time) =>\n  new Promise((res) => setTimeout(res, next_retry_time * 1000));\n\ninstance.interceptors.request.use((config) => {\n  const token = localStorage.getItem(\"api-key\");\n  console.log(\"token\", token);\n  if (token) {\n    config.headers = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    };\n  }\n\n  return config;\n});\n\ninstance.interceptors.response.use(\n  (response) => response.data,\n  async (error) => {\n    if (error.response.status === 429) {\n      const next_retry_time = error.response.headers[\"retry-after\"];\n      console.log(\"Rate limited, retry after\", next_retry_time);\n      if (next_retry_time) {\n        wait(next_retry_time);\n        return instance.request(error.config);\n      }\n    }\n\n    console.log(\"API ERROR\", error);\n    Promise.reject(error);\n  }\n);\n\nexport const getUser = () =>\n  handleResponse(instance.get(\"https://api.spotify.com/v1/me\"));\n\nexport const getPlaylists = () =>\n  handleResponse(instance.get(\"https://api.spotify.com/v1/me/playlists\"));\n\nexport const getTracks = (playlistID) =>\n  handleResponse(\n    instance.get(`https://api.spotify.com/v1/playlists/${playlistID}/tracks`)\n  );\n\nexport const getNextTracks = (next) => handleResponse(instance.get(next));\n\nexport const createPlaylist = (playlistName, userId) =>\n  handleResponse(\n    instance.post(`https://api.spotify.com/v1/users/${userId}/playlists`, {\n      name: playlistName,\n      public: false,\n    })\n  );\n\nexport const deletePlaylist = (playlistID) =>\n  handleResponse(\n    instance.delete(\n      `https://api.spotify.com/v1/playlists/${playlistID}/followers`\n    )\n  );\n\nexport const addTracksToPlaylist = (playlistID, trackIDs) =>\n  handleResponse(\n    instance.post(`https://api.spotify.com/v1/playlists/${playlistID}/tracks`, {\n      uris: trackIDs,\n    })\n  );\n\nexport const searchForTracks = (trackName) => {\n  return handleResponse(\n    instance.get(`https://api.spotify.com/v1/search?q=${trackName}&type=track`)\n  );\n};\n\nclass APIError extends Error {\n  name = \"APIError\";\n}\n\nconst handleResponse = (request) =>\n  request\n    .then((res) => {\n      return res;\n    })\n    .catch((error) => {\n      const message = error.response?.data.error;\n      if (message) {\n        console.error(\"APIError:\", message, error);\n        if (message === \"Invalid access token\") {\n          localStorage.removeItem(\"api-key\");\n        }\n        return new APIError({ ...error, message });\n      } else {\n        return error;\n      }\n    });\n"]},"metadata":{},"sourceType":"module"}