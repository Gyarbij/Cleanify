{"ast":null,"code":"/**\n *     Text diff library ported from Python's difflib module. \n *     Taken from: https://github.com/qiao/difflib.js\n*/\nvar floor = Math.floor,\n    max = Math.max,\n    min = Math.min;\n\nvar _calculateRatio = function _calculateRatio(matches, length) {\n  if (length) {\n    return 2.0 * matches / length;\n  } else {\n    return 1.0;\n  }\n};\n\nvar _arrayCmp = function _arrayCmp(a, b) {\n  var i, la, lb, _i, _ref, _ref1;\n\n  _ref = [a.length, b.length], la = _ref[0], lb = _ref[1];\n\n  for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n    if (a[i] < b[i]) {\n      return -1;\n    }\n\n    if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return la - lb;\n};\n\nvar _has = function _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar _any = function _any(items) {\n  var item, _i, _len;\n\n  for (_i = 0, _len = items.length; _i < _len; _i++) {\n    item = items[_i];\n\n    if (item) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar SequenceMatcher = function () {\n  /*\n    SequenceMatcher is a flexible class for comparing pairs of sequences of\n    any type, so long as the sequence elements are hashable.  The basic\n    algorithm predates, and is a little fancier than, an algorithm\n    published in the late 1980's by Ratcliff and Obershelp under the\n    hyperbolic name \"gestalt pattern matching\".  The basic idea is to find\n    the longest contiguous matching subsequence that contains no \"junk\"\n    elements (R-O doesn't address junk).  The same idea is then applied\n    recursively to the pieces of the sequences to the left and to the right\n    of the matching subsequence.  This does not yield minimal edit\n    sequences, but does tend to yield matches that \"look right\" to people.\n  \n    SequenceMatcher tries to compute a \"human-friendly diff\" between two\n    sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\n    longest *contiguous* & junk-free matching subsequence.  That's what\n    catches peoples' eyes.  The Windows(tm) windiff has another interesting\n    notion, pairing up elements that appear uniquely in each sequence.\n    That, and the method here, appear to yield more intuitive difference\n    reports than does diff.  This method appears to be the least vulnerable\n    to synching up on blocks of \"junk lines\", though (like blank lines in\n    ordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\n    because this is the only method of the 3 that has a *concept* of\n    \"junk\" <wink>.\n  \n    Example, comparing two strings, and considering blanks to be \"junk\":\n  \n    >>> isjunk = (c) -> c is ' '\n    >>> s = new SequenceMatcher(isjunk,\n                                'private Thread currentThread;',\n                                'private volatile Thread currentThread;')\n  \n    .ratio() returns a float in [0, 1], measuring the \"similarity\" of the\n    sequences.  As a rule of thumb, a .ratio() value over 0.6 means the\n    sequences are close matches:\n  \n    >>> s.ratio().toPrecision(3)\n    '0.866'\n  \n    If you're only interested in where the sequences match,\n    .getMatchingBlocks() is handy:\n  \n    >>> for [a, b, size] in s.getMatchingBlocks()\n    ...   console.log(\"a[#{a}] and b[#{b}] match for #{size} elements\");\n    a[0] and b[0] match for 8 elements\n    a[8] and b[17] match for 21 elements\n    a[29] and b[38] match for 0 elements\n  \n    Note that the last tuple returned by .get_matching_blocks() is always a\n    dummy, (len(a), len(b), 0), and this is the only case in which the last\n    tuple element (number of elements matched) is 0.\n  \n    If you want to know how to change the first sequence into the second,\n    use .get_opcodes():\n  \n    >>> for [op, a1, a2, b1, b2] in s.getOpcodes()\n    ...   console.log \"#{op} a[#{a1}:#{a2}] b[#{b1}:#{b2}]\"\n    equal a[0:8] b[0:8]\n    insert a[8:8] b[8:17]\n    equal a[8:29] b[17:38]\n  \n    See the Differ class for a fancy human-friendly file differencer, which\n    uses SequenceMatcher both to compare sequences of lines, and to compare\n    sequences of characters within similar (near-matching) lines.\n  \n    See also function getCloseMatches() in this module, which shows how\n    simple code building on SequenceMatcher can be used to do useful work.\n  \n    Timing:  Basic R-O is cubic time worst case and quadratic time expected\n    case.  SequenceMatcher is quadratic time for the worst case and has\n    expected-case behavior dependent in a complicated way on how many\n    elements the sequences have in common; best case time is linear.\n  \n    Methods:\n  \n    constructor(isjunk=null, a='', b='')\n        Construct a SequenceMatcher.\n  \n    setSeqs(a, b)\n        Set the two sequences to be compared.\n  \n    setSeq1(a)\n        Set the first sequence to be compared.\n  \n    setSeq2(b)\n        Set the second sequence to be compared.\n  \n    findLongestMatch(alo, ahi, blo, bhi)\n        Find longest matching block in a[alo:ahi] and b[blo:bhi].\n  \n    getMatchingBlocks()\n        Return list of triples describing matching subsequences.\n  \n    getOpcodes()\n        Return list of 5-tuples describing how to turn a into b.\n  \n    ratio()\n        Return a measure of the sequences' similarity (float in [0,1]).\n  \n    quickRatio()\n        Return an upper bound on .ratio() relatively quickly.\n  \n    realQuickRatio()\n        Return an upper bound on ratio() very quickly.\n  */\n  function SequenceMatcher(isjunk, a, b, autojunk) {\n    this.isjunk = isjunk;\n\n    if (a == null) {\n      a = '';\n    }\n\n    if (b == null) {\n      b = '';\n    }\n\n    this.autojunk = autojunk != null ? autojunk : true;\n    /*\n        Construct a SequenceMatcher.\n    \n        Optional arg isjunk is null (the default), or a one-argument\n        function that takes a sequence element and returns true iff the\n        element is junk.  Null is equivalent to passing \"(x) -> 0\", i.e.\n        no elements are considered to be junk.  For example, pass\n            (x) -> x in ' \\t'\n        if you're comparing lines as sequences of characters, and don't\n        want to synch up on blanks or hard tabs.\n    \n        Optional arg a is the first of two sequences to be compared.  By\n        default, an empty string.  The elements of a must be hashable.  See\n        also .setSeqs() and .setSeq1().\n    \n        Optional arg b is the second of two sequences to be compared.  By\n        default, an empty string.  The elements of b must be hashable. See\n        also .setSeqs() and .setSeq2().\n    \n        Optional arg autojunk should be set to false to disable the\n        \"automatic junk heuristic\" that treats popular elements as junk\n        (see module documentation for more information).\n    */\n\n    this.a = this.b = null;\n    this.setSeqs(a, b);\n  }\n\n  SequenceMatcher.prototype.setSeqs = function (a, b) {\n    /* \n    Set the two sequences to be compared. \n    \n    >>> s = new SequenceMatcher()\n    >>> s.setSeqs('abcd', 'bcde')\n    >>> s.ratio()\n    0.75\n    */\n    this.setSeq1(a);\n    return this.setSeq2(b);\n  };\n\n  SequenceMatcher.prototype.setSeq1 = function (a) {\n    /* \n    Set the first sequence to be compared. \n    \n    The second sequence to be compared is not changed.\n    \n    >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n    >>> s.ratio()\n    0.75\n    >>> s.setSeq1('bcde')\n    >>> s.ratio()\n    1.0\n    \n    SequenceMatcher computes and caches detailed information about the\n    second sequence, so if you want to compare one sequence S against\n    many sequences, use .setSeq2(S) once and call .setSeq1(x)\n    repeatedly for each of the other sequences.\n    \n    See also setSeqs() and setSeq2().\n    */\n    if (a === this.a) {\n      return;\n    }\n\n    this.a = a;\n    return this.matchingBlocks = this.opcodes = null;\n  };\n\n  SequenceMatcher.prototype.setSeq2 = function (b) {\n    /*\n        Set the second sequence to be compared. \n    \n        The first sequence to be compared is not changed.\n    \n        >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n        >>> s.ratio()\n        0.75\n        >>> s.setSeq2('abcd')\n        >>> s.ratio()\n        1.0\n    \n        SequenceMatcher computes and caches detailed information about the\n        second sequence, so if you want to compare one sequence S against\n        many sequences, use .setSeq2(S) once and call .setSeq1(x)\n        repeatedly for each of the other sequences.\n    \n        See also setSeqs() and setSeq1().\n    */\n    if (b === this.b) {\n      return;\n    }\n\n    this.b = b;\n    this.matchingBlocks = this.opcodes = null;\n    this.fullbcount = null;\n    return this._chainB();\n  };\n\n  SequenceMatcher.prototype._chainB = function () {\n    var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref;\n\n    b = this.b;\n    this.b2j = b2j = {};\n\n    for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n      elt = b[i];\n      indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = [];\n      indices.push(i);\n    }\n\n    junk = {};\n    isjunk = this.isjunk;\n\n    if (isjunk) {\n      _ref = Object.keys(b2j);\n\n      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n        elt = _ref[_j];\n\n        if (isjunk(elt)) {\n          junk[elt] = true;\n          delete b2j[elt];\n        }\n      }\n    }\n\n    popular = {};\n    n = b.length;\n\n    if (this.autojunk && n >= 200) {\n      ntest = floor(n / 100) + 1;\n\n      for (elt in b2j) {\n        idxs = b2j[elt];\n\n        if (idxs.length > ntest) {\n          popular[elt] = true;\n          delete b2j[elt];\n        }\n      }\n    }\n\n    this.isbjunk = function (b) {\n      return _has(junk, b);\n    };\n\n    return this.isbpopular = function (b) {\n      return _has(popular, b);\n    };\n  };\n\n  SequenceMatcher.prototype.findLongestMatch = function (alo, ahi, blo, bhi) {\n    /* \n    Find longest matching block in a[alo...ahi] and b[blo...bhi].  \n    \n    If isjunk is not defined:\n    \n    Return [i,j,k] such that a[i...i+k] is equal to b[j...j+k], where\n        alo <= i <= i+k <= ahi\n        blo <= j <= j+k <= bhi\n    and for all [i',j',k'] meeting those conditions,\n        k >= k'\n        i <= i'\n        and if i == i', j <= j'\n    \n    In other words, of all maximal matching blocks, return one that\n    starts earliest in a, and of all those maximal matching blocks that\n    start earliest in a, return the one that starts earliest in b.\n    \n    >>> isjunk = (x) -> x is ' '\n    >>> s = new SequenceMatcher(isjunk, ' abcd', 'abcd abcd')\n    >>> s.findLongestMatch(0, 5, 0, 9)\n    [1, 0, 4]\n    \n    >>> s = new SequenceMatcher(null, 'ab', 'c')\n    >>> s.findLongestMatch(0, 2, 0, 1)\n    [0, 0, 0]\n    */\n    var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n\n    _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3];\n    _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2];\n    j2len = {};\n\n    for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) {\n      newj2len = {};\n      _ref2 = _has(b2j, a[i]) ? b2j[a[i]] : [];\n\n      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n        j = _ref2[_j];\n\n        if (j < blo) {\n          continue;\n        }\n\n        if (j >= bhi) {\n          break;\n        }\n\n        k = newj2len[j] = (j2len[j - 1] || 0) + 1;\n\n        if (k > bestsize) {\n          _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2];\n        }\n      }\n\n      j2len = newj2len;\n    }\n\n    while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n      _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2];\n    }\n\n    while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n      bestsize++;\n    }\n\n    while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n      _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2];\n    }\n\n    while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n      bestsize++;\n    }\n\n    return [besti, bestj, bestsize];\n  };\n\n  SequenceMatcher.prototype.getMatchingBlocks = function () {\n    /*\n        Return list of triples describing matching subsequences.\n    \n        Each triple is of the form [i, j, n], and means that\n        a[i...i+n] == b[j...j+n].  The triples are monotonically increasing in\n        i and in j.  it's also guaranteed that if\n        [i, j, n] and [i', j', n'] are adjacent triples in the list, and\n        the second is not the last triple in the list, then i+n != i' or\n        j+n != j'.  IOW, adjacent triples never describe adjacent equal\n        blocks.\n    \n        The last triple is a dummy, [a.length, b.length, 0], and is the only\n        triple with n==0.\n    \n        >>> s = new SequenceMatcher(null, 'abxcd', 'abcd')\n        >>> s.getMatchingBlocks()\n        [[0, 0, 2], [3, 2, 2], [5, 4, 0]]\n    */\n    var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;\n\n    if (this.matchingBlocks) {\n      return this.matchingBlocks;\n    }\n\n    _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n    queue = [[0, la, 0, lb]];\n    matchingBlocks = [];\n\n    while (queue.length) {\n      _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3];\n      _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2];\n\n      if (k) {\n        matchingBlocks.push(x);\n\n        if (alo < i && blo < j) {\n          queue.push([alo, i, blo, j]);\n        }\n\n        if (i + k < ahi && j + k < bhi) {\n          queue.push([i + k, ahi, j + k, bhi]);\n        }\n      }\n    }\n\n    matchingBlocks.sort(_arrayCmp);\n    i1 = j1 = k1 = 0;\n    nonAdjacent = [];\n\n    for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) {\n      _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2];\n\n      if (i1 + k1 === i2 && j1 + k1 === j2) {\n        k1 += k2;\n      } else {\n        if (k1) {\n          nonAdjacent.push([i1, j1, k1]);\n        }\n\n        _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2];\n      }\n    }\n\n    if (k1) {\n      nonAdjacent.push([i1, j1, k1]);\n    }\n\n    nonAdjacent.push([la, lb, 0]);\n    return this.matchingBlocks = nonAdjacent;\n  };\n\n  SequenceMatcher.prototype.getOpcodes = function () {\n    /* \n    Return list of 5-tuples describing how to turn a into b.\n    \n    Each tuple is of the form [tag, i1, i2, j1, j2].  The first tuple\n    has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the\n    tuple preceding it, and likewise for j1 == the previous j2.\n    \n    The tags are strings, with these meanings:\n    \n    'replace':  a[i1...i2] should be replaced by b[j1...j2]\n    'delete':   a[i1...i2] should be deleted.\n                Note that j1==j2 in this case.\n    'insert':   b[j1...j2] should be inserted at a[i1...i1].\n                Note that i1==i2 in this case.\n    'equal':    a[i1...i2] == b[j1...j2]\n    \n    >>> s = new SequenceMatcher(null, 'qabxcd', 'abycdf')\n    >>> s.getOpcodes()\n    [ [ 'delete'  , 0 , 1 , 0 , 0 ] ,\n      [ 'equal'   , 1 , 3 , 0 , 2 ] ,\n      [ 'replace' , 3 , 4 , 2 , 3 ] ,\n      [ 'equal'   , 4 , 6 , 3 , 5 ] ,\n      [ 'insert'  , 6 , 6 , 5 , 6 ] ]\n    */\n    var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2;\n\n    if (this.opcodes) {\n      return this.opcodes;\n    }\n\n    i = j = 0;\n    this.opcodes = answer = [];\n    _ref = this.getMatchingBlocks();\n\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2];\n      tag = '';\n\n      if (i < ai && j < bj) {\n        tag = 'replace';\n      } else if (i < ai) {\n        tag = 'delete';\n      } else if (j < bj) {\n        tag = 'insert';\n      }\n\n      if (tag) {\n        answer.push([tag, i, ai, j, bj]);\n      }\n\n      _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1];\n\n      if (size) {\n        answer.push(['equal', ai, i, bj, j]);\n      }\n    }\n\n    return answer;\n  };\n\n  SequenceMatcher.prototype.getGroupedOpcodes = function (n) {\n    var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3;\n\n    if (n == null) {\n      n = 3;\n    }\n    /* \n    Isolate change clusters by eliminating ranges with no changes.\n    \n    Return a list groups with upto n lines of context.\n    Each group is in the same format as returned by get_opcodes().\n    \n    >>> a = [1...40].map(String)\n    >>> b = a.slice()\n    >>> b[8...8] = 'i'\n    >>> b[20] += 'x'\n    >>> b[23...28] = []\n    >>> b[30] += 'y'\n    >>> s = new SequenceMatcher(null, a, b)\n    >>> s.getGroupedOpcodes()\n    [ [ [ 'equal'  , 5 , 8  , 5 , 8 ],\n        [ 'insert' , 8 , 8  , 8 , 9 ],\n        [ 'equal'  , 8 , 11 , 9 , 12 ] ],\n      [ [ 'equal'   , 16 , 19 , 17 , 20 ],\n        [ 'replace' , 19 , 20 , 20 , 21 ],\n        [ 'equal'   , 20 , 22 , 21 , 23 ],\n        [ 'delete'  , 22 , 27 , 23 , 23 ],\n        [ 'equal'   , 27 , 30 , 23 , 26 ] ],\n      [ [ 'equal'   , 31 , 34 , 27 , 30 ],\n        [ 'replace' , 34 , 35 , 30 , 31 ],\n        [ 'equal'   , 35 , 38 , 31 , 34 ] ] ]\n    */\n\n\n    codes = this.getOpcodes();\n\n    if (!codes.length) {\n      codes = [['equal', 0, 1, 0, 1]];\n    }\n\n    if (codes[0][0] === 'equal') {\n      _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4];\n      codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2];\n    }\n\n    if (codes[codes.length - 1][0] === 'equal') {\n      _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4];\n      codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)];\n    }\n\n    nn = n + n;\n    groups = [];\n    group = [];\n\n    for (_i = 0, _len = codes.length; _i < _len; _i++) {\n      _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4];\n\n      if (tag === 'equal' && i2 - i1 > nn) {\n        group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]);\n        groups.push(group);\n        group = [];\n        _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1];\n      }\n\n      group.push([tag, i1, i2, j1, j2]);\n    }\n\n    if (group.length && !(group.length === 1 && group[0][0] === 'equal')) {\n      groups.push(group);\n    }\n\n    return groups;\n  };\n\n  SequenceMatcher.prototype.ratio = function () {\n    /*\n        Return a measure of the sequences' similarity (float in [0,1]).\n    \n        Where T is the total number of elements in both sequences, and\n        M is the number of matches, this is 2.0*M / T.\n        Note that this is 1 if the sequences are identical, and 0 if\n        they have nothing in common.\n    \n        .ratio() is expensive to compute if you haven't already computed\n        .getMatchingBlocks() or .getOpcodes(), in which case you may\n        want to try .quickRatio() or .realQuickRatio() first to get an\n        upper bound.\n        \n        >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n        >>> s.ratio()\n        0.75\n        >>> s.quickRatio()\n        0.75\n        >>> s.realQuickRatio()\n        1.0\n    */\n    var match, matches, _i, _len, _ref;\n\n    matches = 0;\n    _ref = this.getMatchingBlocks();\n\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      match = _ref[_i];\n      matches += match[2];\n    }\n\n    return _calculateRatio(matches, this.a.length + this.b.length);\n  };\n\n  SequenceMatcher.prototype.quickRatio = function () {\n    /*\n        Return an upper bound on ratio() relatively quickly.\n    \n        This isn't defined beyond that it is an upper bound on .ratio(), and\n        is faster to compute.\n    */\n    var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1;\n\n    if (!this.fullbcount) {\n      this.fullbcount = fullbcount = {};\n      _ref = this.b;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elt = _ref[_i];\n        fullbcount[elt] = (fullbcount[elt] || 0) + 1;\n      }\n    }\n\n    fullbcount = this.fullbcount;\n    avail = {};\n    matches = 0;\n    _ref1 = this.a;\n\n    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n      elt = _ref1[_j];\n\n      if (_has(avail, elt)) {\n        numb = avail[elt];\n      } else {\n        numb = fullbcount[elt] || 0;\n      }\n\n      avail[elt] = numb - 1;\n\n      if (numb > 0) {\n        matches++;\n      }\n    }\n\n    return _calculateRatio(matches, this.a.length + this.b.length);\n  };\n\n  SequenceMatcher.prototype.realQuickRatio = function () {\n    /*\n        Return an upper bound on ratio() very quickly.\n    \n        This isn't defined beyond that it is an upper bound on .ratio(), and\n        is faster to compute than either .ratio() or .quickRatio().\n    */\n    var la, lb, _ref;\n\n    _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n    return _calculateRatio(min(la, lb), la + lb);\n  };\n\n  return SequenceMatcher;\n}();\n\nmodule.exports = SequenceMatcher;","map":{"version":3,"sources":["/Users/armanrafati/Documents/Cleanify/client/node_modules/fuzzball/lib/fbdifflib.js"],"names":["floor","Math","max","min","_calculateRatio","matches","length","_arrayCmp","a","b","i","la","lb","_i","_ref","_ref1","_has","obj","key","Object","prototype","hasOwnProperty","call","_any","items","item","_len","SequenceMatcher","isjunk","autojunk","setSeqs","setSeq1","setSeq2","matchingBlocks","opcodes","fullbcount","_chainB","b2j","elt","idxs","indices","junk","n","ntest","popular","_j","_len1","push","keys","isbjunk","isbpopular","findLongestMatch","alo","ahi","blo","bhi","besti","bestj","bestsize","j","j2len","k","newj2len","_ref2","_ref3","_ref4","_ref5","getMatchingBlocks","i1","i2","j1","j2","k1","k2","nonAdjacent","queue","x","pop","sort","getOpcodes","ai","answer","bj","size","tag","getGroupedOpcodes","codes","group","groups","nn","ratio","match","quickRatio","avail","numb","realQuickRatio","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,IAAI,CAACD,KAAjB;AAAA,IAAwBE,GAAG,GAAGD,IAAI,CAACC,GAAnC;AAAA,IAAwCC,GAAG,GAAGF,IAAI,CAACE,GAAnD;;AAEA,IAAIC,eAAe,GAAG,SAAlBA,eAAkB,CAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC7C,MAAIA,MAAJ,EAAY;AACR,WAAO,MAAMD,OAAN,GAAgBC,MAAvB;AACH,GAFD,MAEO;AACH,WAAO,GAAP;AACH;AACJ,CAND;;AAQA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC5B,MAAIC,CAAJ,EAAOC,EAAP,EAAWC,EAAX,EAAeC,EAAf,EAAmBC,IAAnB,EAAyBC,KAAzB;;AACAD,EAAAA,IAAI,GAAG,CAACN,CAAC,CAACF,MAAH,EAAWG,CAAC,CAACH,MAAb,CAAP,EAA6BK,EAAE,GAAGG,IAAI,CAAC,CAAD,CAAtC,EAA2CF,EAAE,GAAGE,IAAI,CAAC,CAAD,CAApD;;AACA,OAAKJ,CAAC,GAAGG,EAAE,GAAG,CAAT,EAAYE,KAAK,GAAGZ,GAAG,CAACQ,EAAD,EAAKC,EAAL,CAA5B,EAAsC,KAAKG,KAAL,GAAaF,EAAE,GAAGE,KAAlB,GAA0BF,EAAE,GAAGE,KAArE,EAA4EL,CAAC,GAAG,KAAKK,KAAL,GAAa,EAAEF,EAAf,GAAoB,EAAEA,EAAtG,EAA0G;AACtG,QAAIL,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAZ,EAAiB;AACb,aAAO,CAAC,CAAR;AACH;;AACD,QAAIF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAZ,EAAiB;AACb,aAAO,CAAP;AACH;AACJ;;AACD,SAAOC,EAAE,GAAGC,EAAZ;AACH,CAZD;;AAcA,IAAII,IAAI,GAAG,SAAPA,IAAO,CAAUC,GAAV,EAAeC,GAAf,EAAoB;AAC3B,SAAOC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAArC,EAA0CC,GAA1C,CAAP;AACH,CAFD;;AAIA,IAAIK,IAAI,GAAG,SAAPA,IAAO,CAAUC,KAAV,EAAiB;AACxB,MAAIC,IAAJ,EAAUZ,EAAV,EAAca,IAAd;;AACA,OAAKb,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAGF,KAAK,CAAClB,MAA1B,EAAkCO,EAAE,GAAGa,IAAvC,EAA6Cb,EAAE,EAA/C,EAAmD;AAC/CY,IAAAA,IAAI,GAAGD,KAAK,CAACX,EAAD,CAAZ;;AACA,QAAIY,IAAJ,EAAU;AACN,aAAO,IAAP;AACH;AACJ;;AACD,SAAO,KAAP;AACH,CATD;;AAWA,IAAIE,eAAe,GAAI,YAAY;AAE/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGI,WAASA,eAAT,CAAyBC,MAAzB,EAAiCpB,CAAjC,EAAoCC,CAApC,EAAuCoB,QAAvC,EAAiD;AAC7C,SAAKD,MAAL,GAAcA,MAAd;;AACA,QAAIpB,CAAC,IAAI,IAAT,EAAe;AACXA,MAAAA,CAAC,GAAG,EAAJ;AACH;;AACD,QAAIC,CAAC,IAAI,IAAT,EAAe;AACXA,MAAAA,CAAC,GAAG,EAAJ;AACH;;AACD,SAAKoB,QAAL,GAAgBA,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8B,IAA9C;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ,SAAKrB,CAAL,GAAS,KAAKC,CAAL,GAAS,IAAlB;AACA,SAAKqB,OAAL,CAAatB,CAAb,EAAgBC,CAAhB;AACH;;AAEDkB,EAAAA,eAAe,CAACP,SAAhB,CAA0BU,OAA1B,GAAoC,UAAUtB,CAAV,EAAaC,CAAb,EAAgB;AAChD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAAKsB,OAAL,CAAavB,CAAb;AACA,WAAO,KAAKwB,OAAL,CAAavB,CAAb,CAAP;AACH,GAXD;;AAaAkB,EAAAA,eAAe,CAACP,SAAhB,CAA0BW,OAA1B,GAAoC,UAAUvB,CAAV,EAAa;AAC7C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,QAAIA,CAAC,KAAK,KAAKA,CAAf,EAAkB;AACd;AACH;;AACD,SAAKA,CAAL,GAASA,CAAT;AACA,WAAO,KAAKyB,cAAL,GAAsB,KAAKC,OAAL,GAAe,IAA5C;AACH,GAzBD;;AA2BAP,EAAAA,eAAe,CAACP,SAAhB,CAA0BY,OAA1B,GAAoC,UAAUvB,CAAV,EAAa;AAC7C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,QAAIA,CAAC,KAAK,KAAKA,CAAf,EAAkB;AACd;AACH;;AACD,SAAKA,CAAL,GAASA,CAAT;AACA,SAAKwB,cAAL,GAAsB,KAAKC,OAAL,GAAe,IAArC;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,WAAO,KAAKC,OAAL,EAAP;AACH,GA3BD;;AA6BAT,EAAAA,eAAe,CAACP,SAAhB,CAA0BgB,OAA1B,GAAoC,YAAY;AAC5C,QAAI3B,CAAJ,EAAO4B,GAAP,EAAYC,GAAZ,EAAiB5B,CAAjB,EAAoB6B,IAApB,EAA0BC,OAA1B,EAAmCZ,MAAnC,EAA2Ca,IAA3C,EAAiDC,CAAjD,EAAoDC,KAApD,EAA2DC,OAA3D,EAAoE/B,EAApE,EAAwEgC,EAAxE,EAA4EnB,IAA5E,EAAkFoB,KAAlF,EAAyFhC,IAAzF;;AACAL,IAAAA,CAAC,GAAG,KAAKA,CAAT;AACA,SAAK4B,GAAL,GAAWA,GAAG,GAAG,EAAjB;;AACA,SAAK3B,CAAC,GAAGG,EAAE,GAAG,CAAT,EAAYa,IAAI,GAAGjB,CAAC,CAACH,MAA1B,EAAkCO,EAAE,GAAGa,IAAvC,EAA6ChB,CAAC,GAAG,EAAEG,EAAnD,EAAuD;AACnDyB,MAAAA,GAAG,GAAG7B,CAAC,CAACC,CAAD,CAAP;AACA8B,MAAAA,OAAO,GAAGxB,IAAI,CAACqB,GAAD,EAAMC,GAAN,CAAJ,GAAiBD,GAAG,CAACC,GAAD,CAApB,GAA4BD,GAAG,CAACC,GAAD,CAAH,GAAW,EAAjD;AACAE,MAAAA,OAAO,CAACO,IAAR,CAAarC,CAAb;AACH;;AACD+B,IAAAA,IAAI,GAAG,EAAP;AACAb,IAAAA,MAAM,GAAG,KAAKA,MAAd;;AACA,QAAIA,MAAJ,EAAY;AACRd,MAAAA,IAAI,GAAGK,MAAM,CAAC6B,IAAP,CAAYX,GAAZ,CAAP;;AACA,WAAKQ,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAGhC,IAAI,CAACR,MAA1B,EAAkCuC,EAAE,GAAGC,KAAvC,EAA8CD,EAAE,EAAhD,EAAoD;AAChDP,QAAAA,GAAG,GAAGxB,IAAI,CAAC+B,EAAD,CAAV;;AACA,YAAIjB,MAAM,CAACU,GAAD,CAAV,EAAiB;AACbG,UAAAA,IAAI,CAACH,GAAD,CAAJ,GAAY,IAAZ;AACA,iBAAOD,GAAG,CAACC,GAAD,CAAV;AACH;AACJ;AACJ;;AACDM,IAAAA,OAAO,GAAG,EAAV;AACAF,IAAAA,CAAC,GAAGjC,CAAC,CAACH,MAAN;;AACA,QAAI,KAAKuB,QAAL,IAAiBa,CAAC,IAAI,GAA1B,EAA+B;AAC3BC,MAAAA,KAAK,GAAG3C,KAAK,CAAC0C,CAAC,GAAG,GAAL,CAAL,GAAiB,CAAzB;;AACA,WAAKJ,GAAL,IAAYD,GAAZ,EAAiB;AACbE,QAAAA,IAAI,GAAGF,GAAG,CAACC,GAAD,CAAV;;AACA,YAAIC,IAAI,CAACjC,MAAL,GAAcqC,KAAlB,EAAyB;AACrBC,UAAAA,OAAO,CAACN,GAAD,CAAP,GAAe,IAAf;AACA,iBAAOD,GAAG,CAACC,GAAD,CAAV;AACH;AACJ;AACJ;;AACD,SAAKW,OAAL,GAAe,UAAUxC,CAAV,EAAa;AACxB,aAAOO,IAAI,CAACyB,IAAD,EAAOhC,CAAP,CAAX;AACH,KAFD;;AAGA,WAAO,KAAKyC,UAAL,GAAkB,UAAUzC,CAAV,EAAa;AAClC,aAAOO,IAAI,CAAC4B,OAAD,EAAUnC,CAAV,CAAX;AACH,KAFD;AAGH,GAvCD;;AAyCAkB,EAAAA,eAAe,CAACP,SAAhB,CAA0B+B,gBAA1B,GAA6C,UAAUC,GAAV,EAAeC,GAAf,EAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AACvE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEQ,QAAI/C,CAAJ,EAAOC,CAAP,EAAU4B,GAAV,EAAemB,KAAf,EAAsBC,KAAtB,EAA6BC,QAA7B,EAAuChD,CAAvC,EAA0CuC,OAA1C,EAAmDU,CAAnD,EAAsDC,KAAtD,EAA6DC,CAA7D,EAAgEC,QAAhE,EAA0EjD,EAA1E,EAA8EgC,EAA9E,EAAkFnB,IAAlF,EAAwFZ,IAAxF,EAA8FC,KAA9F,EAAqGgD,KAArG,EAA4GC,KAA5G,EAAmHC,KAAnH,EAA0HC,KAA1H;;AACApD,IAAAA,IAAI,GAAG,CAAC,KAAKN,CAAN,EAAS,KAAKC,CAAd,EAAiB,KAAK4B,GAAtB,EAA2B,KAAKY,OAAhC,CAAP,EAAiDzC,CAAC,GAAGM,IAAI,CAAC,CAAD,CAAzD,EAA8DL,CAAC,GAAGK,IAAI,CAAC,CAAD,CAAtE,EAA2EuB,GAAG,GAAGvB,IAAI,CAAC,CAAD,CAArF,EAA0FmC,OAAO,GAAGnC,IAAI,CAAC,CAAD,CAAxG;AACAC,IAAAA,KAAK,GAAG,CAACqC,GAAD,EAAME,GAAN,EAAW,CAAX,CAAR,EAAuBE,KAAK,GAAGzC,KAAK,CAAC,CAAD,CAApC,EAAyC0C,KAAK,GAAG1C,KAAK,CAAC,CAAD,CAAtD,EAA2D2C,QAAQ,GAAG3C,KAAK,CAAC,CAAD,CAA3E;AACA6C,IAAAA,KAAK,GAAG,EAAR;;AACA,SAAKlD,CAAC,GAAGG,EAAE,GAAGuC,GAAd,EAAmBA,GAAG,IAAIC,GAAP,GAAaxC,EAAE,GAAGwC,GAAlB,GAAwBxC,EAAE,GAAGwC,GAAhD,EAAqD3C,CAAC,GAAG0C,GAAG,IAAIC,GAAP,GAAa,EAAExC,EAAf,GAAoB,EAAEA,EAA/E,EAAmF;AAC/EiD,MAAAA,QAAQ,GAAG,EAAX;AACAC,MAAAA,KAAK,GAAI/C,IAAI,CAACqB,GAAD,EAAM7B,CAAC,CAACE,CAAD,CAAP,CAAJ,GAAkB2B,GAAG,CAAC7B,CAAC,CAACE,CAAD,CAAF,CAArB,GAA8B,EAAvC;;AACA,WAAKmC,EAAE,GAAG,CAAL,EAAQnB,IAAI,GAAGqC,KAAK,CAACzD,MAA1B,EAAkCuC,EAAE,GAAGnB,IAAvC,EAA6CmB,EAAE,EAA/C,EAAmD;AAC/Cc,QAAAA,CAAC,GAAGI,KAAK,CAAClB,EAAD,CAAT;;AACA,YAAIc,CAAC,GAAGL,GAAR,EAAa;AACT;AACH;;AACD,YAAIK,CAAC,IAAIJ,GAAT,EAAc;AACV;AACH;;AACDM,QAAAA,CAAC,GAAGC,QAAQ,CAACH,CAAD,CAAR,GAAc,CAACC,KAAK,CAACD,CAAC,GAAG,CAAL,CAAL,IAAgB,CAAjB,IAAsB,CAAxC;;AACA,YAAIE,CAAC,GAAGH,QAAR,EAAkB;AACdM,UAAAA,KAAK,GAAG,CAACtD,CAAC,GAAGmD,CAAJ,GAAQ,CAAT,EAAYF,CAAC,GAAGE,CAAJ,GAAQ,CAApB,EAAuBA,CAAvB,CAAR,EAAmCL,KAAK,GAAGQ,KAAK,CAAC,CAAD,CAAhD,EAAqDP,KAAK,GAAGO,KAAK,CAAC,CAAD,CAAlE,EAAuEN,QAAQ,GAAGM,KAAK,CAAC,CAAD,CAAvF;AACH;AACJ;;AACDJ,MAAAA,KAAK,GAAGE,QAAR;AACH;;AACD,WAAON,KAAK,GAAGJ,GAAR,IAAeK,KAAK,GAAGH,GAAvB,IAA8B,CAACL,OAAO,CAACxC,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAF,CAAtC,IAAwDjD,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAD,KAAiB/C,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAjF,EAA8F;AAC1FQ,MAAAA,KAAK,GAAG,CAACT,KAAK,GAAG,CAAT,EAAYC,KAAK,GAAG,CAApB,EAAuBC,QAAQ,GAAG,CAAlC,CAAR,EAA8CF,KAAK,GAAGS,KAAK,CAAC,CAAD,CAA3D,EAAgER,KAAK,GAAGQ,KAAK,CAAC,CAAD,CAA7E,EAAkFP,QAAQ,GAAGO,KAAK,CAAC,CAAD,CAAlG;AACH;;AACD,WAAOT,KAAK,GAAGE,QAAR,GAAmBL,GAAnB,IAA0BI,KAAK,GAAGC,QAAR,GAAmBH,GAA7C,IAAoD,CAACN,OAAO,CAACxC,CAAC,CAACgD,KAAK,GAAGC,QAAT,CAAF,CAA5D,IAAqFlD,CAAC,CAACgD,KAAK,GAAGE,QAAT,CAAD,KAAwBjD,CAAC,CAACgD,KAAK,GAAGC,QAAT,CAArH,EAAyI;AACrIA,MAAAA,QAAQ;AACX;;AACD,WAAOF,KAAK,GAAGJ,GAAR,IAAeK,KAAK,GAAGH,GAAvB,IAA8BL,OAAO,CAACxC,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAF,CAArC,IAAuDjD,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAD,KAAiB/C,CAAC,CAACgD,KAAK,GAAG,CAAT,CAAhF,EAA6F;AACzFS,MAAAA,KAAK,GAAG,CAACV,KAAK,GAAG,CAAT,EAAYC,KAAK,GAAG,CAApB,EAAuBC,QAAQ,GAAG,CAAlC,CAAR,EAA8CF,KAAK,GAAGU,KAAK,CAAC,CAAD,CAA3D,EAAgET,KAAK,GAAGS,KAAK,CAAC,CAAD,CAA7E,EAAkFR,QAAQ,GAAGQ,KAAK,CAAC,CAAD,CAAlG;AACH;;AACD,WAAOV,KAAK,GAAGE,QAAR,GAAmBL,GAAnB,IAA0BI,KAAK,GAAGC,QAAR,GAAmBH,GAA7C,IAAoDN,OAAO,CAACxC,CAAC,CAACgD,KAAK,GAAGC,QAAT,CAAF,CAA3D,IAAoFlD,CAAC,CAACgD,KAAK,GAAGE,QAAT,CAAD,KAAwBjD,CAAC,CAACgD,KAAK,GAAGC,QAAT,CAApH,EAAwI;AACpIA,MAAAA,QAAQ;AACX;;AACD,WAAO,CAACF,KAAD,EAAQC,KAAR,EAAeC,QAAf,CAAP;AACH,GA/DD;;AAiEA/B,EAAAA,eAAe,CAACP,SAAhB,CAA0B+C,iBAA1B,GAA8C,YAAY;AACtD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEQ,QAAId,GAAJ,EAASD,GAAT,EAAcG,GAAd,EAAmBD,GAAnB,EAAwB5C,CAAxB,EAA2B0D,EAA3B,EAA+BC,EAA/B,EAAmCV,CAAnC,EAAsCW,EAAtC,EAA0CC,EAA1C,EAA8CV,CAA9C,EAAiDW,EAAjD,EAAqDC,EAArD,EAAyD9D,EAAzD,EAA6DC,EAA7D,EAAiEqB,cAAjE,EAAiFyC,WAAjF,EAA8FC,KAA9F,EAAqGC,CAArG,EAAwG/D,EAAxG,EAA4Ga,IAA5G,EAAkHZ,IAAlH,EAAwHC,KAAxH,EAA+HgD,KAA/H,EAAsIC,KAAtI,EAA6IC,KAA7I;;AACA,QAAI,KAAKhC,cAAT,EAAyB;AACrB,aAAO,KAAKA,cAAZ;AACH;;AACDnB,IAAAA,IAAI,GAAG,CAAC,KAAKN,CAAL,CAAOF,MAAR,EAAgB,KAAKG,CAAL,CAAOH,MAAvB,CAAP,EAAuCK,EAAE,GAAGG,IAAI,CAAC,CAAD,CAAhD,EAAqDF,EAAE,GAAGE,IAAI,CAAC,CAAD,CAA9D;AACA6D,IAAAA,KAAK,GAAG,CAAC,CAAC,CAAD,EAAIhE,EAAJ,EAAQ,CAAR,EAAWC,EAAX,CAAD,CAAR;AACAqB,IAAAA,cAAc,GAAG,EAAjB;;AACA,WAAO0C,KAAK,CAACrE,MAAb,EAAqB;AACjBS,MAAAA,KAAK,GAAG4D,KAAK,CAACE,GAAN,EAAR,EAAqBzB,GAAG,GAAGrC,KAAK,CAAC,CAAD,CAAhC,EAAqCsC,GAAG,GAAGtC,KAAK,CAAC,CAAD,CAAhD,EAAqDuC,GAAG,GAAGvC,KAAK,CAAC,CAAD,CAAhE,EAAqEwC,GAAG,GAAGxC,KAAK,CAAC,CAAD,CAAhF;AACAgD,MAAAA,KAAK,GAAGa,CAAC,GAAG,KAAKzB,gBAAL,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgCC,GAAhC,EAAqCC,GAArC,CAAZ,EAAuD7C,CAAC,GAAGqD,KAAK,CAAC,CAAD,CAAhE,EAAqEJ,CAAC,GAAGI,KAAK,CAAC,CAAD,CAA9E,EAAmFF,CAAC,GAAGE,KAAK,CAAC,CAAD,CAA5F;;AACA,UAAIF,CAAJ,EAAO;AACH5B,QAAAA,cAAc,CAACc,IAAf,CAAoB6B,CAApB;;AACA,YAAIxB,GAAG,GAAG1C,CAAN,IAAW4C,GAAG,GAAGK,CAArB,EAAwB;AACpBgB,UAAAA,KAAK,CAAC5B,IAAN,CAAW,CAACK,GAAD,EAAM1C,CAAN,EAAS4C,GAAT,EAAcK,CAAd,CAAX;AACH;;AACD,YAAIjD,CAAC,GAAGmD,CAAJ,GAAQR,GAAR,IAAeM,CAAC,GAAGE,CAAJ,GAAQN,GAA3B,EAAgC;AAC5BoB,UAAAA,KAAK,CAAC5B,IAAN,CAAW,CAACrC,CAAC,GAAGmD,CAAL,EAAQR,GAAR,EAAaM,CAAC,GAAGE,CAAjB,EAAoBN,GAApB,CAAX;AACH;AACJ;AACJ;;AACDtB,IAAAA,cAAc,CAAC6C,IAAf,CAAoBvE,SAApB;AACA6D,IAAAA,EAAE,GAAGE,EAAE,GAAGE,EAAE,GAAG,CAAf;AACAE,IAAAA,WAAW,GAAG,EAAd;;AACA,SAAK7D,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAGO,cAAc,CAAC3B,MAAnC,EAA2CO,EAAE,GAAGa,IAAhD,EAAsDb,EAAE,EAAxD,EAA4D;AACxDmD,MAAAA,KAAK,GAAG/B,cAAc,CAACpB,EAAD,CAAtB,EAA4BwD,EAAE,GAAGL,KAAK,CAAC,CAAD,CAAtC,EAA2CO,EAAE,GAAGP,KAAK,CAAC,CAAD,CAArD,EAA0DS,EAAE,GAAGT,KAAK,CAAC,CAAD,CAApE;;AACA,UAAII,EAAE,GAAGI,EAAL,KAAYH,EAAZ,IAAkBC,EAAE,GAAGE,EAAL,KAAYD,EAAlC,EAAsC;AAClCC,QAAAA,EAAE,IAAIC,EAAN;AACH,OAFD,MAEO;AACH,YAAID,EAAJ,EAAQ;AACJE,UAAAA,WAAW,CAAC3B,IAAZ,CAAiB,CAACqB,EAAD,EAAKE,EAAL,EAASE,EAAT,CAAjB;AACH;;AACDP,QAAAA,KAAK,GAAG,CAACI,EAAD,EAAKE,EAAL,EAASE,EAAT,CAAR,EAAsBL,EAAE,GAAGH,KAAK,CAAC,CAAD,CAAhC,EAAqCK,EAAE,GAAGL,KAAK,CAAC,CAAD,CAA/C,EAAoDO,EAAE,GAAGP,KAAK,CAAC,CAAD,CAA9D;AACH;AACJ;;AACD,QAAIO,EAAJ,EAAQ;AACJE,MAAAA,WAAW,CAAC3B,IAAZ,CAAiB,CAACqB,EAAD,EAAKE,EAAL,EAASE,EAAT,CAAjB;AACH;;AACDE,IAAAA,WAAW,CAAC3B,IAAZ,CAAiB,CAACpC,EAAD,EAAKC,EAAL,EAAS,CAAT,CAAjB;AACA,WAAO,KAAKqB,cAAL,GAAsByC,WAA7B;AACH,GA3DD;;AA6DA/C,EAAAA,eAAe,CAACP,SAAhB,CAA0B2D,UAA1B,GAAuC,YAAY;AAC/C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEQ,QAAIC,EAAJ,EAAQC,MAAR,EAAgBC,EAAhB,EAAoBxE,CAApB,EAAuBiD,CAAvB,EAA0BwB,IAA1B,EAAgCC,GAAhC,EAAqCvE,EAArC,EAAyCa,IAAzC,EAA+CZ,IAA/C,EAAqDC,KAArD,EAA4DgD,KAA5D;;AACA,QAAI,KAAK7B,OAAT,EAAkB;AACd,aAAO,KAAKA,OAAZ;AACH;;AACDxB,IAAAA,CAAC,GAAGiD,CAAC,GAAG,CAAR;AACA,SAAKzB,OAAL,GAAe+C,MAAM,GAAG,EAAxB;AACAnE,IAAAA,IAAI,GAAG,KAAKqD,iBAAL,EAAP;;AACA,SAAKtD,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAGZ,IAAI,CAACR,MAAzB,EAAiCO,EAAE,GAAGa,IAAtC,EAA4Cb,EAAE,EAA9C,EAAkD;AAC9CE,MAAAA,KAAK,GAAGD,IAAI,CAACD,EAAD,CAAZ,EAAkBmE,EAAE,GAAGjE,KAAK,CAAC,CAAD,CAA5B,EAAiCmE,EAAE,GAAGnE,KAAK,CAAC,CAAD,CAA3C,EAAgDoE,IAAI,GAAGpE,KAAK,CAAC,CAAD,CAA5D;AACAqE,MAAAA,GAAG,GAAG,EAAN;;AACA,UAAI1E,CAAC,GAAGsE,EAAJ,IAAUrB,CAAC,GAAGuB,EAAlB,EAAsB;AAClBE,QAAAA,GAAG,GAAG,SAAN;AACH,OAFD,MAEO,IAAI1E,CAAC,GAAGsE,EAAR,EAAY;AACfI,QAAAA,GAAG,GAAG,QAAN;AACH,OAFM,MAEA,IAAIzB,CAAC,GAAGuB,EAAR,EAAY;AACfE,QAAAA,GAAG,GAAG,QAAN;AACH;;AACD,UAAIA,GAAJ,EAAS;AACLH,QAAAA,MAAM,CAAClC,IAAP,CAAY,CAACqC,GAAD,EAAM1E,CAAN,EAASsE,EAAT,EAAarB,CAAb,EAAgBuB,EAAhB,CAAZ;AACH;;AACDnB,MAAAA,KAAK,GAAG,CAACiB,EAAE,GAAGG,IAAN,EAAYD,EAAE,GAAGC,IAAjB,CAAR,EAAgCzE,CAAC,GAAGqD,KAAK,CAAC,CAAD,CAAzC,EAA8CJ,CAAC,GAAGI,KAAK,CAAC,CAAD,CAAvD;;AACA,UAAIoB,IAAJ,EAAU;AACNF,QAAAA,MAAM,CAAClC,IAAP,CAAY,CAAC,OAAD,EAAUiC,EAAV,EAActE,CAAd,EAAiBwE,EAAjB,EAAqBvB,CAArB,CAAZ;AACH;AACJ;;AACD,WAAOsB,MAAP;AACH,GApDD;;AAsDAtD,EAAAA,eAAe,CAACP,SAAhB,CAA0BiE,iBAA1B,GAA8C,UAAU3C,CAAV,EAAa;AACvD,QAAI4C,KAAJ,EAAWC,KAAX,EAAkBC,MAAlB,EAA0BpB,EAA1B,EAA8BC,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0CkB,EAA1C,EAA8CL,GAA9C,EAAmDvE,EAAnD,EAAuDa,IAAvD,EAA6DZ,IAA7D,EAAmEC,KAAnE,EAA0EgD,KAA1E,EAAiFC,KAAjF;;AACA,QAAItB,CAAC,IAAI,IAAT,EAAe;AACXA,MAAAA,CAAC,GAAG,CAAJ;AACH;AACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEQ4C,IAAAA,KAAK,GAAG,KAAKP,UAAL,EAAR;;AACA,QAAI,CAACO,KAAK,CAAChF,MAAX,EAAmB;AACfgF,MAAAA,KAAK,GAAG,CAAC,CAAC,OAAD,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,CAAD,CAAR;AACH;;AACD,QAAIA,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,MAAgB,OAApB,EAA6B;AACzBxE,MAAAA,IAAI,GAAGwE,KAAK,CAAC,CAAD,CAAZ,EAAiBF,GAAG,GAAGtE,IAAI,CAAC,CAAD,CAA3B,EAAgCsD,EAAE,GAAGtD,IAAI,CAAC,CAAD,CAAzC,EAA8CuD,EAAE,GAAGvD,IAAI,CAAC,CAAD,CAAvD,EAA4DwD,EAAE,GAAGxD,IAAI,CAAC,CAAD,CAArE,EAA0EyD,EAAE,GAAGzD,IAAI,CAAC,CAAD,CAAnF;AACAwE,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAW,CAACF,GAAD,EAAMlF,GAAG,CAACkE,EAAD,EAAKC,EAAE,GAAG3B,CAAV,CAAT,EAAuB2B,EAAvB,EAA2BnE,GAAG,CAACoE,EAAD,EAAKC,EAAE,GAAG7B,CAAV,CAA9B,EAA4C6B,EAA5C,CAAX;AACH;;AACD,QAAIe,KAAK,CAACA,KAAK,CAAChF,MAAN,GAAe,CAAhB,CAAL,CAAwB,CAAxB,MAA+B,OAAnC,EAA4C;AACxCS,MAAAA,KAAK,GAAGuE,KAAK,CAACA,KAAK,CAAChF,MAAN,GAAe,CAAhB,CAAb,EAAiC8E,GAAG,GAAGrE,KAAK,CAAC,CAAD,CAA5C,EAAiDqD,EAAE,GAAGrD,KAAK,CAAC,CAAD,CAA3D,EAAgEsD,EAAE,GAAGtD,KAAK,CAAC,CAAD,CAA1E,EAA+EuD,EAAE,GAAGvD,KAAK,CAAC,CAAD,CAAzF,EAA8FwD,EAAE,GAAGxD,KAAK,CAAC,CAAD,CAAxG;AACAuE,MAAAA,KAAK,CAACA,KAAK,CAAChF,MAAN,GAAe,CAAhB,CAAL,GAA0B,CAAC8E,GAAD,EAAMhB,EAAN,EAAUjE,GAAG,CAACkE,EAAD,EAAKD,EAAE,GAAG1B,CAAV,CAAb,EAA2B4B,EAA3B,EAA+BnE,GAAG,CAACoE,EAAD,EAAKD,EAAE,GAAG5B,CAAV,CAAlC,CAA1B;AACH;;AACD+C,IAAAA,EAAE,GAAG/C,CAAC,GAAGA,CAAT;AACA8C,IAAAA,MAAM,GAAG,EAAT;AACAD,IAAAA,KAAK,GAAG,EAAR;;AACA,SAAK1E,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAG4D,KAAK,CAAChF,MAA1B,EAAkCO,EAAE,GAAGa,IAAvC,EAA6Cb,EAAE,EAA/C,EAAmD;AAC/CkD,MAAAA,KAAK,GAAGuB,KAAK,CAACzE,EAAD,CAAb,EAAmBuE,GAAG,GAAGrB,KAAK,CAAC,CAAD,CAA9B,EAAmCK,EAAE,GAAGL,KAAK,CAAC,CAAD,CAA7C,EAAkDM,EAAE,GAAGN,KAAK,CAAC,CAAD,CAA5D,EAAiEO,EAAE,GAAGP,KAAK,CAAC,CAAD,CAA3E,EAAgFQ,EAAE,GAAGR,KAAK,CAAC,CAAD,CAA1F;;AACA,UAAIqB,GAAG,KAAK,OAAR,IAAmBf,EAAE,GAAGD,EAAL,GAAUqB,EAAjC,EAAqC;AACjCF,QAAAA,KAAK,CAACxC,IAAN,CAAW,CAACqC,GAAD,EAAMhB,EAAN,EAAUjE,GAAG,CAACkE,EAAD,EAAKD,EAAE,GAAG1B,CAAV,CAAb,EAA2B4B,EAA3B,EAA+BnE,GAAG,CAACoE,EAAD,EAAKD,EAAE,GAAG5B,CAAV,CAAlC,CAAX;AACA8C,QAAAA,MAAM,CAACzC,IAAP,CAAYwC,KAAZ;AACAA,QAAAA,KAAK,GAAG,EAAR;AACAvB,QAAAA,KAAK,GAAG,CAAC9D,GAAG,CAACkE,EAAD,EAAKC,EAAE,GAAG3B,CAAV,CAAJ,EAAkBxC,GAAG,CAACoE,EAAD,EAAKC,EAAE,GAAG7B,CAAV,CAArB,CAAR,EAA4C0B,EAAE,GAAGJ,KAAK,CAAC,CAAD,CAAtD,EAA2DM,EAAE,GAAGN,KAAK,CAAC,CAAD,CAArE;AACH;;AACDuB,MAAAA,KAAK,CAACxC,IAAN,CAAW,CAACqC,GAAD,EAAMhB,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,CAAX;AACH;;AACD,QAAIgB,KAAK,CAACjF,MAAN,IAAgB,EAAEiF,KAAK,CAACjF,MAAN,KAAiB,CAAjB,IAAsBiF,KAAK,CAAC,CAAD,CAAL,CAAS,CAAT,MAAgB,OAAxC,CAApB,EAAsE;AAClEC,MAAAA,MAAM,CAACzC,IAAP,CAAYwC,KAAZ;AACH;;AACD,WAAOC,MAAP;AACH,GA7DD;;AA+DA7D,EAAAA,eAAe,CAACP,SAAhB,CAA0BsE,KAA1B,GAAkC,YAAY;AAC1C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEQ,QAAIC,KAAJ,EAAWtF,OAAX,EAAoBQ,EAApB,EAAwBa,IAAxB,EAA8BZ,IAA9B;;AACAT,IAAAA,OAAO,GAAG,CAAV;AACAS,IAAAA,IAAI,GAAG,KAAKqD,iBAAL,EAAP;;AACA,SAAKtD,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAGZ,IAAI,CAACR,MAAzB,EAAiCO,EAAE,GAAGa,IAAtC,EAA4Cb,EAAE,EAA9C,EAAkD;AAC9C8E,MAAAA,KAAK,GAAG7E,IAAI,CAACD,EAAD,CAAZ;AACAR,MAAAA,OAAO,IAAIsF,KAAK,CAAC,CAAD,CAAhB;AACH;;AACD,WAAOvF,eAAe,CAACC,OAAD,EAAU,KAAKG,CAAL,CAAOF,MAAP,GAAgB,KAAKG,CAAL,CAAOH,MAAjC,CAAtB;AACH,GA/BD;;AAiCAqB,EAAAA,eAAe,CAACP,SAAhB,CAA0BwE,UAA1B,GAAuC,YAAY;AAC/C;AACR;AACA;AACA;AACA;AACA;AAEQ,QAAIC,KAAJ,EAAWvD,GAAX,EAAgBH,UAAhB,EAA4B9B,OAA5B,EAAqCyF,IAArC,EAA2CjF,EAA3C,EAA+CgC,EAA/C,EAAmDnB,IAAnD,EAAyDoB,KAAzD,EAAgEhC,IAAhE,EAAsEC,KAAtE;;AACA,QAAI,CAAC,KAAKoB,UAAV,EAAsB;AAClB,WAAKA,UAAL,GAAkBA,UAAU,GAAG,EAA/B;AACArB,MAAAA,IAAI,GAAG,KAAKL,CAAZ;;AACA,WAAKI,EAAE,GAAG,CAAL,EAAQa,IAAI,GAAGZ,IAAI,CAACR,MAAzB,EAAiCO,EAAE,GAAGa,IAAtC,EAA4Cb,EAAE,EAA9C,EAAkD;AAC9CyB,QAAAA,GAAG,GAAGxB,IAAI,CAACD,EAAD,CAAV;AACAsB,QAAAA,UAAU,CAACG,GAAD,CAAV,GAAkB,CAACH,UAAU,CAACG,GAAD,CAAV,IAAmB,CAApB,IAAyB,CAA3C;AACH;AACJ;;AACDH,IAAAA,UAAU,GAAG,KAAKA,UAAlB;AACA0D,IAAAA,KAAK,GAAG,EAAR;AACAxF,IAAAA,OAAO,GAAG,CAAV;AACAU,IAAAA,KAAK,GAAG,KAAKP,CAAb;;AACA,SAAKqC,EAAE,GAAG,CAAL,EAAQC,KAAK,GAAG/B,KAAK,CAACT,MAA3B,EAAmCuC,EAAE,GAAGC,KAAxC,EAA+CD,EAAE,EAAjD,EAAqD;AACjDP,MAAAA,GAAG,GAAGvB,KAAK,CAAC8B,EAAD,CAAX;;AACA,UAAI7B,IAAI,CAAC6E,KAAD,EAAQvD,GAAR,CAAR,EAAsB;AAClBwD,QAAAA,IAAI,GAAGD,KAAK,CAACvD,GAAD,CAAZ;AACH,OAFD,MAEO;AACHwD,QAAAA,IAAI,GAAG3D,UAAU,CAACG,GAAD,CAAV,IAAmB,CAA1B;AACH;;AACDuD,MAAAA,KAAK,CAACvD,GAAD,CAAL,GAAawD,IAAI,GAAG,CAApB;;AACA,UAAIA,IAAI,GAAG,CAAX,EAAc;AACVzF,QAAAA,OAAO;AACV;AACJ;;AACD,WAAOD,eAAe,CAACC,OAAD,EAAU,KAAKG,CAAL,CAAOF,MAAP,GAAgB,KAAKG,CAAL,CAAOH,MAAjC,CAAtB;AACH,GAlCD;;AAoCAqB,EAAAA,eAAe,CAACP,SAAhB,CAA0B2E,cAA1B,GAA2C,YAAY;AACnD;AACR;AACA;AACA;AACA;AACA;AAEQ,QAAIpF,EAAJ,EAAQC,EAAR,EAAYE,IAAZ;;AACAA,IAAAA,IAAI,GAAG,CAAC,KAAKN,CAAL,CAAOF,MAAR,EAAgB,KAAKG,CAAL,CAAOH,MAAvB,CAAP,EAAuCK,EAAE,GAAGG,IAAI,CAAC,CAAD,CAAhD,EAAqDF,EAAE,GAAGE,IAAI,CAAC,CAAD,CAA9D;AACA,WAAOV,eAAe,CAACD,GAAG,CAACQ,EAAD,EAAKC,EAAL,CAAJ,EAAcD,EAAE,GAAGC,EAAnB,CAAtB;AACH,GAXD;;AAaA,SAAOe,eAAP;AAEH,CAtkBqB,EAAtB;;AAwkBAqE,MAAM,CAACC,OAAP,GAAiBtE,eAAjB","sourcesContent":["/**\n *     Text diff library ported from Python's difflib module. \n *     Taken from: https://github.com/qiao/difflib.js\n*/\n\nvar floor = Math.floor, max = Math.max, min = Math.min;\n\nvar _calculateRatio = function (matches, length) {\n    if (length) {\n        return 2.0 * matches / length;\n    } else {\n        return 1.0;\n    }\n};\n\nvar _arrayCmp = function (a, b) {\n    var i, la, lb, _i, _ref, _ref1;\n    _ref = [a.length, b.length], la = _ref[0], lb = _ref[1];\n    for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        if (a[i] > b[i]) {\n            return 1;\n        }\n    }\n    return la - lb;\n};\n\nvar _has = function (obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar _any = function (items) {\n    var item, _i, _len;\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n        item = items[_i];\n        if (item) {\n            return true;\n        }\n    }\n    return false;\n};\n\nvar SequenceMatcher = (function () {\n\n    /*\n      SequenceMatcher is a flexible class for comparing pairs of sequences of\n      any type, so long as the sequence elements are hashable.  The basic\n      algorithm predates, and is a little fancier than, an algorithm\n      published in the late 1980's by Ratcliff and Obershelp under the\n      hyperbolic name \"gestalt pattern matching\".  The basic idea is to find\n      the longest contiguous matching subsequence that contains no \"junk\"\n      elements (R-O doesn't address junk).  The same idea is then applied\n      recursively to the pieces of the sequences to the left and to the right\n      of the matching subsequence.  This does not yield minimal edit\n      sequences, but does tend to yield matches that \"look right\" to people.\n    \n      SequenceMatcher tries to compute a \"human-friendly diff\" between two\n      sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\n      longest *contiguous* & junk-free matching subsequence.  That's what\n      catches peoples' eyes.  The Windows(tm) windiff has another interesting\n      notion, pairing up elements that appear uniquely in each sequence.\n      That, and the method here, appear to yield more intuitive difference\n      reports than does diff.  This method appears to be the least vulnerable\n      to synching up on blocks of \"junk lines\", though (like blank lines in\n      ordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\n      because this is the only method of the 3 that has a *concept* of\n      \"junk\" <wink>.\n    \n      Example, comparing two strings, and considering blanks to be \"junk\":\n    \n      >>> isjunk = (c) -> c is ' '\n      >>> s = new SequenceMatcher(isjunk,\n                                  'private Thread currentThread;',\n                                  'private volatile Thread currentThread;')\n    \n      .ratio() returns a float in [0, 1], measuring the \"similarity\" of the\n      sequences.  As a rule of thumb, a .ratio() value over 0.6 means the\n      sequences are close matches:\n    \n      >>> s.ratio().toPrecision(3)\n      '0.866'\n    \n      If you're only interested in where the sequences match,\n      .getMatchingBlocks() is handy:\n    \n      >>> for [a, b, size] in s.getMatchingBlocks()\n      ...   console.log(\"a[#{a}] and b[#{b}] match for #{size} elements\");\n      a[0] and b[0] match for 8 elements\n      a[8] and b[17] match for 21 elements\n      a[29] and b[38] match for 0 elements\n    \n      Note that the last tuple returned by .get_matching_blocks() is always a\n      dummy, (len(a), len(b), 0), and this is the only case in which the last\n      tuple element (number of elements matched) is 0.\n    \n      If you want to know how to change the first sequence into the second,\n      use .get_opcodes():\n    \n      >>> for [op, a1, a2, b1, b2] in s.getOpcodes()\n      ...   console.log \"#{op} a[#{a1}:#{a2}] b[#{b1}:#{b2}]\"\n      equal a[0:8] b[0:8]\n      insert a[8:8] b[8:17]\n      equal a[8:29] b[17:38]\n    \n      See the Differ class for a fancy human-friendly file differencer, which\n      uses SequenceMatcher both to compare sequences of lines, and to compare\n      sequences of characters within similar (near-matching) lines.\n    \n      See also function getCloseMatches() in this module, which shows how\n      simple code building on SequenceMatcher can be used to do useful work.\n    \n      Timing:  Basic R-O is cubic time worst case and quadratic time expected\n      case.  SequenceMatcher is quadratic time for the worst case and has\n      expected-case behavior dependent in a complicated way on how many\n      elements the sequences have in common; best case time is linear.\n    \n      Methods:\n    \n      constructor(isjunk=null, a='', b='')\n          Construct a SequenceMatcher.\n    \n      setSeqs(a, b)\n          Set the two sequences to be compared.\n    \n      setSeq1(a)\n          Set the first sequence to be compared.\n    \n      setSeq2(b)\n          Set the second sequence to be compared.\n    \n      findLongestMatch(alo, ahi, blo, bhi)\n          Find longest matching block in a[alo:ahi] and b[blo:bhi].\n    \n      getMatchingBlocks()\n          Return list of triples describing matching subsequences.\n    \n      getOpcodes()\n          Return list of 5-tuples describing how to turn a into b.\n    \n      ratio()\n          Return a measure of the sequences' similarity (float in [0,1]).\n    \n      quickRatio()\n          Return an upper bound on .ratio() relatively quickly.\n    \n      realQuickRatio()\n          Return an upper bound on ratio() very quickly.\n    */\n\n\n    function SequenceMatcher(isjunk, a, b, autojunk) {\n        this.isjunk = isjunk;\n        if (a == null) {\n            a = '';\n        }\n        if (b == null) {\n            b = '';\n        }\n        this.autojunk = autojunk != null ? autojunk : true;\n        /*\n            Construct a SequenceMatcher.\n        \n            Optional arg isjunk is null (the default), or a one-argument\n            function that takes a sequence element and returns true iff the\n            element is junk.  Null is equivalent to passing \"(x) -> 0\", i.e.\n            no elements are considered to be junk.  For example, pass\n                (x) -> x in ' \\t'\n            if you're comparing lines as sequences of characters, and don't\n            want to synch up on blanks or hard tabs.\n        \n            Optional arg a is the first of two sequences to be compared.  By\n            default, an empty string.  The elements of a must be hashable.  See\n            also .setSeqs() and .setSeq1().\n        \n            Optional arg b is the second of two sequences to be compared.  By\n            default, an empty string.  The elements of b must be hashable. See\n            also .setSeqs() and .setSeq2().\n        \n            Optional arg autojunk should be set to false to disable the\n            \"automatic junk heuristic\" that treats popular elements as junk\n            (see module documentation for more information).\n        */\n\n        this.a = this.b = null;\n        this.setSeqs(a, b);\n    }\n\n    SequenceMatcher.prototype.setSeqs = function (a, b) {\n        /* \n        Set the two sequences to be compared. \n        \n        >>> s = new SequenceMatcher()\n        >>> s.setSeqs('abcd', 'bcde')\n        >>> s.ratio()\n        0.75\n        */\n        this.setSeq1(a);\n        return this.setSeq2(b);\n    };\n\n    SequenceMatcher.prototype.setSeq1 = function (a) {\n        /* \n        Set the first sequence to be compared. \n        \n        The second sequence to be compared is not changed.\n        \n        >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n        >>> s.ratio()\n        0.75\n        >>> s.setSeq1('bcde')\n        >>> s.ratio()\n        1.0\n        \n        SequenceMatcher computes and caches detailed information about the\n        second sequence, so if you want to compare one sequence S against\n        many sequences, use .setSeq2(S) once and call .setSeq1(x)\n        repeatedly for each of the other sequences.\n        \n        See also setSeqs() and setSeq2().\n        */\n        if (a === this.a) {\n            return;\n        }\n        this.a = a;\n        return this.matchingBlocks = this.opcodes = null;\n    };\n\n    SequenceMatcher.prototype.setSeq2 = function (b) {\n        /*\n            Set the second sequence to be compared. \n        \n            The first sequence to be compared is not changed.\n        \n            >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n            >>> s.ratio()\n            0.75\n            >>> s.setSeq2('abcd')\n            >>> s.ratio()\n            1.0\n        \n            SequenceMatcher computes and caches detailed information about the\n            second sequence, so if you want to compare one sequence S against\n            many sequences, use .setSeq2(S) once and call .setSeq1(x)\n            repeatedly for each of the other sequences.\n        \n            See also setSeqs() and setSeq1().\n        */\n        if (b === this.b) {\n            return;\n        }\n        this.b = b;\n        this.matchingBlocks = this.opcodes = null;\n        this.fullbcount = null;\n        return this._chainB();\n    };\n\n    SequenceMatcher.prototype._chainB = function () {\n        var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref;\n        b = this.b;\n        this.b2j = b2j = {};\n        for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {\n            elt = b[i];\n            indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = [];\n            indices.push(i);\n        }\n        junk = {};\n        isjunk = this.isjunk;\n        if (isjunk) {\n            _ref = Object.keys(b2j);\n            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n                elt = _ref[_j];\n                if (isjunk(elt)) {\n                    junk[elt] = true;\n                    delete b2j[elt];\n                }\n            }\n        }\n        popular = {};\n        n = b.length;\n        if (this.autojunk && n >= 200) {\n            ntest = floor(n / 100) + 1;\n            for (elt in b2j) {\n                idxs = b2j[elt];\n                if (idxs.length > ntest) {\n                    popular[elt] = true;\n                    delete b2j[elt];\n                }\n            }\n        }\n        this.isbjunk = function (b) {\n            return _has(junk, b);\n        };\n        return this.isbpopular = function (b) {\n            return _has(popular, b);\n        };\n    };\n\n    SequenceMatcher.prototype.findLongestMatch = function (alo, ahi, blo, bhi) {\n        /* \n        Find longest matching block in a[alo...ahi] and b[blo...bhi].  \n        \n        If isjunk is not defined:\n        \n        Return [i,j,k] such that a[i...i+k] is equal to b[j...j+k], where\n            alo <= i <= i+k <= ahi\n            blo <= j <= j+k <= bhi\n        and for all [i',j',k'] meeting those conditions,\n            k >= k'\n            i <= i'\n            and if i == i', j <= j'\n        \n        In other words, of all maximal matching blocks, return one that\n        starts earliest in a, and of all those maximal matching blocks that\n        start earliest in a, return the one that starts earliest in b.\n        \n        >>> isjunk = (x) -> x is ' '\n        >>> s = new SequenceMatcher(isjunk, ' abcd', 'abcd abcd')\n        >>> s.findLongestMatch(0, 5, 0, 9)\n        [1, 0, 4]\n        \n        >>> s = new SequenceMatcher(null, 'ab', 'c')\n        >>> s.findLongestMatch(0, 2, 0, 1)\n        [0, 0, 0]\n        */\n\n        var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n        _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3];\n        _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2];\n        j2len = {};\n        for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) {\n            newj2len = {};\n            _ref2 = (_has(b2j, a[i]) ? b2j[a[i]] : []);\n            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n                j = _ref2[_j];\n                if (j < blo) {\n                    continue;\n                }\n                if (j >= bhi) {\n                    break;\n                }\n                k = newj2len[j] = (j2len[j - 1] || 0) + 1;\n                if (k > bestsize) {\n                    _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2];\n                }\n            }\n            j2len = newj2len;\n        }\n        while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n            _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2];\n        }\n        while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n            bestsize++;\n        }\n        while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {\n            _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2];\n        }\n        while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {\n            bestsize++;\n        }\n        return [besti, bestj, bestsize];\n    };\n\n    SequenceMatcher.prototype.getMatchingBlocks = function () {\n        /*\n            Return list of triples describing matching subsequences.\n        \n            Each triple is of the form [i, j, n], and means that\n            a[i...i+n] == b[j...j+n].  The triples are monotonically increasing in\n            i and in j.  it's also guaranteed that if\n            [i, j, n] and [i', j', n'] are adjacent triples in the list, and\n            the second is not the last triple in the list, then i+n != i' or\n            j+n != j'.  IOW, adjacent triples never describe adjacent equal\n            blocks.\n        \n            The last triple is a dummy, [a.length, b.length, 0], and is the only\n            triple with n==0.\n        \n            >>> s = new SequenceMatcher(null, 'abxcd', 'abcd')\n            >>> s.getMatchingBlocks()\n            [[0, 0, 2], [3, 2, 2], [5, 4, 0]]\n        */\n\n        var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;\n        if (this.matchingBlocks) {\n            return this.matchingBlocks;\n        }\n        _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n        queue = [[0, la, 0, lb]];\n        matchingBlocks = [];\n        while (queue.length) {\n            _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3];\n            _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2];\n            if (k) {\n                matchingBlocks.push(x);\n                if (alo < i && blo < j) {\n                    queue.push([alo, i, blo, j]);\n                }\n                if (i + k < ahi && j + k < bhi) {\n                    queue.push([i + k, ahi, j + k, bhi]);\n                }\n            }\n        }\n        matchingBlocks.sort(_arrayCmp);\n        i1 = j1 = k1 = 0;\n        nonAdjacent = [];\n        for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) {\n            _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2];\n            if (i1 + k1 === i2 && j1 + k1 === j2) {\n                k1 += k2;\n            } else {\n                if (k1) {\n                    nonAdjacent.push([i1, j1, k1]);\n                }\n                _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2];\n            }\n        }\n        if (k1) {\n            nonAdjacent.push([i1, j1, k1]);\n        }\n        nonAdjacent.push([la, lb, 0]);\n        return this.matchingBlocks = nonAdjacent;\n    };\n\n    SequenceMatcher.prototype.getOpcodes = function () {\n        /* \n        Return list of 5-tuples describing how to turn a into b.\n        \n        Each tuple is of the form [tag, i1, i2, j1, j2].  The first tuple\n        has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the\n        tuple preceding it, and likewise for j1 == the previous j2.\n        \n        The tags are strings, with these meanings:\n        \n        'replace':  a[i1...i2] should be replaced by b[j1...j2]\n        'delete':   a[i1...i2] should be deleted.\n                    Note that j1==j2 in this case.\n        'insert':   b[j1...j2] should be inserted at a[i1...i1].\n                    Note that i1==i2 in this case.\n        'equal':    a[i1...i2] == b[j1...j2]\n        \n        >>> s = new SequenceMatcher(null, 'qabxcd', 'abycdf')\n        >>> s.getOpcodes()\n        [ [ 'delete'  , 0 , 1 , 0 , 0 ] ,\n          [ 'equal'   , 1 , 3 , 0 , 2 ] ,\n          [ 'replace' , 3 , 4 , 2 , 3 ] ,\n          [ 'equal'   , 4 , 6 , 3 , 5 ] ,\n          [ 'insert'  , 6 , 6 , 5 , 6 ] ]\n        */\n\n        var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2;\n        if (this.opcodes) {\n            return this.opcodes;\n        }\n        i = j = 0;\n        this.opcodes = answer = [];\n        _ref = this.getMatchingBlocks();\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2];\n            tag = '';\n            if (i < ai && j < bj) {\n                tag = 'replace';\n            } else if (i < ai) {\n                tag = 'delete';\n            } else if (j < bj) {\n                tag = 'insert';\n            }\n            if (tag) {\n                answer.push([tag, i, ai, j, bj]);\n            }\n            _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1];\n            if (size) {\n                answer.push(['equal', ai, i, bj, j]);\n            }\n        }\n        return answer;\n    };\n\n    SequenceMatcher.prototype.getGroupedOpcodes = function (n) {\n        var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3;\n        if (n == null) {\n            n = 3;\n        }\n        /* \n        Isolate change clusters by eliminating ranges with no changes.\n        \n        Return a list groups with upto n lines of context.\n        Each group is in the same format as returned by get_opcodes().\n        \n        >>> a = [1...40].map(String)\n        >>> b = a.slice()\n        >>> b[8...8] = 'i'\n        >>> b[20] += 'x'\n        >>> b[23...28] = []\n        >>> b[30] += 'y'\n        >>> s = new SequenceMatcher(null, a, b)\n        >>> s.getGroupedOpcodes()\n        [ [ [ 'equal'  , 5 , 8  , 5 , 8 ],\n            [ 'insert' , 8 , 8  , 8 , 9 ],\n            [ 'equal'  , 8 , 11 , 9 , 12 ] ],\n          [ [ 'equal'   , 16 , 19 , 17 , 20 ],\n            [ 'replace' , 19 , 20 , 20 , 21 ],\n            [ 'equal'   , 20 , 22 , 21 , 23 ],\n            [ 'delete'  , 22 , 27 , 23 , 23 ],\n            [ 'equal'   , 27 , 30 , 23 , 26 ] ],\n          [ [ 'equal'   , 31 , 34 , 27 , 30 ],\n            [ 'replace' , 34 , 35 , 30 , 31 ],\n            [ 'equal'   , 35 , 38 , 31 , 34 ] ] ]\n        */\n\n        codes = this.getOpcodes();\n        if (!codes.length) {\n            codes = [['equal', 0, 1, 0, 1]];\n        }\n        if (codes[0][0] === 'equal') {\n            _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4];\n            codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2];\n        }\n        if (codes[codes.length - 1][0] === 'equal') {\n            _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4];\n            codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)];\n        }\n        nn = n + n;\n        groups = [];\n        group = [];\n        for (_i = 0, _len = codes.length; _i < _len; _i++) {\n            _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4];\n            if (tag === 'equal' && i2 - i1 > nn) {\n                group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]);\n                groups.push(group);\n                group = [];\n                _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1];\n            }\n            group.push([tag, i1, i2, j1, j2]);\n        }\n        if (group.length && !(group.length === 1 && group[0][0] === 'equal')) {\n            groups.push(group);\n        }\n        return groups;\n    };\n\n    SequenceMatcher.prototype.ratio = function () {\n        /*\n            Return a measure of the sequences' similarity (float in [0,1]).\n        \n            Where T is the total number of elements in both sequences, and\n            M is the number of matches, this is 2.0*M / T.\n            Note that this is 1 if the sequences are identical, and 0 if\n            they have nothing in common.\n        \n            .ratio() is expensive to compute if you haven't already computed\n            .getMatchingBlocks() or .getOpcodes(), in which case you may\n            want to try .quickRatio() or .realQuickRatio() first to get an\n            upper bound.\n            \n            >>> s = new SequenceMatcher(null, 'abcd', 'bcde')\n            >>> s.ratio()\n            0.75\n            >>> s.quickRatio()\n            0.75\n            >>> s.realQuickRatio()\n            1.0\n        */\n\n        var match, matches, _i, _len, _ref;\n        matches = 0;\n        _ref = this.getMatchingBlocks();\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            match = _ref[_i];\n            matches += match[2];\n        }\n        return _calculateRatio(matches, this.a.length + this.b.length);\n    };\n\n    SequenceMatcher.prototype.quickRatio = function () {\n        /*\n            Return an upper bound on ratio() relatively quickly.\n        \n            This isn't defined beyond that it is an upper bound on .ratio(), and\n            is faster to compute.\n        */\n\n        var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1;\n        if (!this.fullbcount) {\n            this.fullbcount = fullbcount = {};\n            _ref = this.b;\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                elt = _ref[_i];\n                fullbcount[elt] = (fullbcount[elt] || 0) + 1;\n            }\n        }\n        fullbcount = this.fullbcount;\n        avail = {};\n        matches = 0;\n        _ref1 = this.a;\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            elt = _ref1[_j];\n            if (_has(avail, elt)) {\n                numb = avail[elt];\n            } else {\n                numb = fullbcount[elt] || 0;\n            }\n            avail[elt] = numb - 1;\n            if (numb > 0) {\n                matches++;\n            }\n        }\n        return _calculateRatio(matches, this.a.length + this.b.length);\n    };\n\n    SequenceMatcher.prototype.realQuickRatio = function () {\n        /*\n            Return an upper bound on ratio() very quickly.\n        \n            This isn't defined beyond that it is an upper bound on .ratio(), and\n            is faster to compute than either .ratio() or .quickRatio().\n        */\n\n        var la, lb, _ref;\n        _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];\n        return _calculateRatio(min(la, lb), la + lb);\n    };\n\n    return SequenceMatcher;\n\n})();\n\nmodule.exports = SequenceMatcher;\n"]},"metadata":{},"sourceType":"script"}